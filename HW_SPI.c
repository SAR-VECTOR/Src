/******************** (C) COPYRIGHT 2022 << VECTOR >> ********************
 * File Name          : HW_SPI.c
 * Author             : Electronic Devices Application Team
 * Version            : V1.01
 * Date               : 11/2022
 * Description        : Управление подпрограммами работы интерфейса SPI
 ********************************************************************************/


/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32l1xx_it.h"
#include "HW_SPI.h"
/* Private includes ----------------------------------------------------------*/
/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define FM25CL64_WREN				0x06
#define FM25CL64_WRDI				0x04
#define FM25CL64_RDSR				0x05
#define FM25CL64_WRSR				0x01
#define FM25CL64_READ				0x03
#define FM25CL64_WRITE			0x02
#define FM25CL64_PROTECT 		0x0c
#define FM25CL64_UNPROTECT	0x00

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private user code ---------------------------------------------------------*/

/* External variables --------------------------------------------------------*/
extern SPI_HandleTypeDef hspi2;




/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    DataTransmitToFRAM_SPI2 - запись данных в память FRAM посредством SPI2

  @param    1)*u8_p_TransmitData:       ссылка на байтовый массив данных, которые нужно записать во FRAM
  @param    2)u8_SizeOfTransmitData:    размер массива пересылаемых данных
  @param    3)u16_StartAddressInFRAM:   адрес, с которого будет происходить запись (адресное простр-во FRAM 0...1FFFh (0...8191))

  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка


   -----------   Теория работы:
  1.
  При включении питания микросхемы FRAM запись в её регистры и ячейки памяти запрещена.
  Команда разрешения записи WREN (WRite ENable) должна быть выдана перед любой операцией записи.
  Отправка команды WREN позволит выдавать последующие команды для операций записи.
      WREN --> Set Write Enable Latch --> 0000 0110b (06h)
  Отправка команды WREN взводит бит блокировки разрешения дальнейшей записи 1-->WEL в регистре статуса (Status register), впрямую
    записать в бит WEL единицу не удастся, только через команду WREN.
  После каждой операции записи и после команд WRDI, WRSR или WRITE бит WEL в регистре статуса сбрасывается в ноль (0-->WEL) для
    дальнейшей защиты памяти от случайного доступа
  -------------
  2.
  Команда WRDI (WRite DIsable) запрещает все операции записи, снимая блокировку разрешения записи (0-->WEL)
      WRDI --> Write Disable --> 0000 0100b (04h)
  -------------
  3.
  Команда RDSR позволяет ведущему устройству шины проверять содержимое регистра состояния (Status register).
  Выполняя команду RDSR, микросхема FM25CL64B вернет один байт с содержимым регистра состояния.
      RDSR --> Read Status Register --> 0000 0101b (05h)
  
    Status Register:
  Bit:  7     6   5   4   3   2   1   0 
  Name: WPEN  0   0   0   BP1 BP0 WEL 0 
  -------------
  4.
  Команда WRSR – запись в регистр состояния (Status register).
  Перед отправкой команды WRSR следует отправить команду WREN (см. п. 1), чтобы включить запись.
  Следующий за командой WRSR байт прописывает информацию в регистр состояния (Status register).
      WRSR --> Write Status Register --> 0000 0001b (01h)

    Status Register:
  Bit:  7     6   5   4   3   2   1   0 
  Name: WPEN  0   0   0   BP1 BP0 WEL 0 
  
  BP1 и BP0 - это биты защиты от записи в блок памяти. Они определяют участки памяти, защищенные от записи, как показано в следующей таблице.
  
  Block Memory Write Protection:
  BP1 BP0 Protected Address Range 
  0   0   None 
  0   1   1800h to 1FFFh (upper ?) 
  1   0   1000h to 1FFFh (upper ?) 
  1   1   0000h to 1FFFh (all) 

  Бит WPEN управляет действием аппаратного /WP-вывода. Когда WPEN==0 состояние пина /WP игнорируется.
  Когда значение WPEN высокое, пин /WP управляет доступом на запись в регистр состояния.
  Таким образом, регистр состояния защищен от записи, если бит WPEN=1 и вход /WP=0.
  --------------
  5.
  Операция записи в память.
  Все записи в память начинаются с управляющей команды WREN, в начале которой пин /CS устанавливается в нижнее (нулевое) состояние, 
  и пока не закончится запись данных в память остаётся в этом состоянии.
  Следующая команда - WRITE
        WRITE --> Write Memory Data --> 0000 0010b (02h)
  За кодом команды записи следует двухбайтовое значение адреса.
  Старшие 3 бита адреса игнорируются. В общей сложности 13 бит определяют адрес первого байта данных операции записи.
  Это начальный адрес первого байта данных операции записи. Последующие байты - это байты данных, которые записываются последовательно.
  Адреса увеличиваются внутренне до тех пор, пока мастер шины продолжает выдавать тактовые частоты и поддерживает /CS на низком уровне.
  Если будет достигнут последний адрес 1FFFh, счетчик переключится на 0000h. Впереди идёт MSB (старший бит байта данных).
  Восходящий фронт /CS завершает операцию записи.
  ---------------
  6.
  Операция чтения из памяти.
  После переднего ниспадающего фронта /CS мастер шины может выдать команду READ.
        READ --> Read Memory Data --> 0000 0011b (03h)
  За командой READ следует двухбайтовое значение адреса. Верхние 3 бита адреса игнорируются.
  В общей сложности 13 бит определяют адрес первого байта операции чтения.
  Это начальный адрес первого байта операции чтения. После выдачи команды и адреса
  устройство выводит считанные из памяти данные в ходе следующих 8 тактов. Вход данных SI игнорируется во время чтения
  байтов данных. Последующие байты - это байты данных, которые считываются последовательно. Адреса увеличиваются
  внутренне до тех пор, пока мастер шины продолжает выдавать тактовые частоты и вход /CS низкий.
  Если последний адрес 1FFFh достигнут, счетчик переключится на 0000h. В каждом байте сначала идёт старший бит данных MSB.
  Восходящий фронт /CS завершает операцию чтения.

  @example
    DataTransmitToFRAM_SPI2 (u_TransmitData.u8_ArrayData, sizeof (g_s_DataFromSensor), 0x5A);
  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef DataTransmitToFRAM_SPI2 (u8 *u8_p_TransmitData, u8 u8_SizeOfTransmitData, u16 u16_StartAddressInFRAM)
{
  HAL_StatusTypeDef ReturnStatus;
  u8 u8_a_DataToSend[128];
  u8 u8_DataCounter=0;

  //* --------------------------------------- Проверка, включено ли питание FRAM ---------------------------------------------------
  // Читаем из порта его текущее состояние
  if (DRV_FRAM_GPIO_Port->ODR & DRV_FRAM_Pin) // если питание FRAM ВЫКЛючено (порт находится в "1"),...
  {
    // ...ВКЛючаем питание FRAM (сбрасываем линию порта в "0")
    PowerSwitch (FRAM_POWER, POWER_ON);

    // Даём задержку для инициализации по включению питания микросхемы FRAM
    HAL_Delay(15); // согласно Datsheet задержка при ВКЛючении FRAM должна быть не менее 10мс
  }

  //* ------------------------------------ На всякий случай проверяем линию CS2 ---------------------------------------------------
  // если CS2 в "нуле",...
  if ( 0 == (SPI2_CS2_GPIO_Port->ODR & SPI2_CS2_Pin) ) 
  {
    // ... то устанавливаем её в исходное состояние (в "1")
    HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);
    HAL_Delay(1);
  }

  //*---------------------------------------- Отключение защиты записи FRAM -------------------------------------------------------
  // CS2: "1" --> "0"
  HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_RESET);

  // FM25CL64_WREN --> FRAM (команда на отключение защиты записи)
  u8_a_DataToSend[0] = FM25CL64_WREN;
  if ( HAL_OK != (ReturnStatus = HAL_SPI_Transmit (&hspi2, u8_a_DataToSend, 1, 100) ) )
  {
    HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);
    return ReturnStatus;
  }
	
  // CS2: "1" --> "0"    Защёлкиваем данные во FRAM
  HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);


  //* -------------------------------------- Запись данных измерений во FRAM ------------------------------------------------------
  // FM25CL64_WRITE --> FRAM (команда на запись данных)
  u8_a_DataToSend[u8_DataCounter++] = FM25CL64_WRITE;
  // Начальный адрес записи данных во FRAM
  u8_a_DataToSend[u8_DataCounter++] = (u8)((u16_StartAddressInFRAM >> 8) & 0x00ff);
  u8_a_DataToSend[u8_DataCounter++] = (u8)(u16_StartAddressInFRAM & 0x00ff);

  // Перекидываем входные данные в выходной буферный массив
  for (u8 u8_Counter = 0; u8_Counter < u8_SizeOfTransmitData; u8_Counter++)
  {
    u8_a_DataToSend[u8_DataCounter++] = *(u8_p_TransmitData++);
  }

  // CS2: "1" --> "0" // стартует фрейм для записи во FRAM
  HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_RESET);

  // Запись данных во FRAM
  // HAL_SPI_Transmit (&hspi2, u8_a_DataToSend, u8_DataCounter, 200);
  if ( HAL_OK != (ReturnStatus = HAL_SPI_Transmit (&hspi2, u8_a_DataToSend, u8_DataCounter, 200) ) )
  {
    HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);
    return ReturnStatus;
  }

  // CS2: "1" --> "0"    Защёлкиваем данные во FRAM
  HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);

  return HAL_OK;

}








/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    DataReceiveFromFRAM_SPI2 - чтение данных из памяти FRAM посредством SPI2

  @param    1)*u8_p_TransmitData:       ссылка на байтовый массив данных, которые нужно записать во FRAM
  @param    2)u8_SizeOfTransmitData:    размер массива пересылаемых данных
  @param    3)u16_StartAddressInFRAM:   адрес, с которого будет происходить запись (адресное простр-во FRAM 0...1FFFh (0...8191))

  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка


   -----------   Теория работы:
  1.
  При включении питания микросхемы FRAM запись в её регистры и ячейки памяти запрещена.
  Команда разрешения записи WREN (WRite ENable) должна быть выдана перед любой операцией записи.
  Отправка команды WREN позволит выдавать последующие команды для операций записи.
      WREN --> Set Write Enable Latch --> 0000 0110b (06h)
  Отправка команды WREN взводит бит блокировки разрешения дальнейшей записи 1-->WEL в регистре статуса (Status register), впрямую
    записать в бит WEL единицу не удастся, только через команду WREN.
  После каждой операции записи и после команд WRDI, WRSR или WRITE бит WEL в регистре статуса сбрасывается в ноль (0-->WEL) для
    дальнейшей защиты памяти от случайного доступа
  -------------
  2.
  Команда WRDI (WRite DIsable) запрещает все операции записи, снимая блокировку разрешения записи (0-->WEL)
      WRDI --> Write Disable --> 0000 0100b (04h)
  -------------
  3.
  Команда RDSR позволяет ведущему устройству шины проверять содержимое регистра состояния (Status register).
  Выполняя команду RDSR, микросхема FM25CL64B вернет один байт с содержимым регистра состояния.
      RDSR --> Read Status Register --> 0000 0101b (05h)
  
    Status Register:
  Bit:  7     6   5   4   3   2   1   0 
  Name: WPEN  0   0   0   BP1 BP0 WEL 0 
  -------------
  4.
  Команда WRSR – запись в регистр состояния (Status register).
  Перед отправкой команды WRSR следует отправить команду WREN (см. п. 1), чтобы включить запись.
  Следующий за командой WRSR байт прописывает информацию в регистр состояния (Status register).
      WRSR --> Write Status Register --> 0000 0001b (01h)

    Status Register:
  Bit:  7     6   5   4   3   2   1   0 
  Name: WPEN  0   0   0   BP1 BP0 WEL 0 
  
  BP1 и BP0 - это биты защиты от записи в блок памяти. Они определяют участки памяти, защищенные от записи, как показано в следующей таблице.
  
  Block Memory Write Protection:
  BP1 BP0 Protected Address Range 
  0   0   None 
  0   1   1800h to 1FFFh (upper ?) 
  1   0   1000h to 1FFFh (upper ?) 
  1   1   0000h to 1FFFh (all) 

  Бит WPEN управляет действием аппаратного /WP-вывода. Когда WPEN==0 состояние пина /WP игнорируется.
  Когда значение WPEN высокое, пин /WP управляет доступом на запись в регистр состояния.
  Таким образом, регистр состояния защищен от записи, если бит WPEN=1 и вход /WP=0.
  --------------
  5.
  Операция записи в память.
  Все записи в память начинаются с управляющей команды WREN, в начале которой пин /CS устанавливается в нижнее (нулевое) состояние, 
  и пока не закончится запись данных в память остаётся в этом состоянии.
  Следующая команда - WRITE
        WRITE --> Write Memory Data --> 0000 0010b (02h)
  За кодом команды записи следует двухбайтовое значение адреса.
  Старшие 3 бита адреса игнорируются. В общей сложности 13 бит определяют адрес первого байта данных операции записи.
  Это начальный адрес первого байта данных операции записи. Последующие байты - это байты данных, которые записываются последовательно.
  Адреса увеличиваются внутренне до тех пор, пока мастер шины продолжает выдавать тактовые частоты и поддерживает /CS на низком уровне.
  Если будет достигнут последний адрес 1FFFh, счетчик переключится на 0000h. Впереди идёт MSB (старший бит байта данных).
  Восходящий фронт /CS завершает операцию записи.
  ---------------
  6.
  Операция чтения из памяти.
  После переднего ниспадающего фронта /CS мастер шины может выдать команду READ.
        READ --> Read Memory Data --> 0000 0011b (03h)
  За командой READ следует двухбайтовое значение адреса. Верхние 3 бита адреса игнорируются.
  В общей сложности 13 бит определяют адрес первого байта операции чтения.
  Это начальный адрес первого байта операции чтения. После выдачи команды и адреса
  устройство выводит считанные из памяти данные в ходе следующих 8 тактов. Вход данных SI игнорируется во время чтения
  байтов данных. Последующие байты - это байты данных, которые считываются последовательно. Адреса увеличиваются
  внутренне до тех пор, пока мастер шины продолжает выдавать тактовые частоты и вход /CS низкий.
  Если последний адрес 1FFFh достигнут, счетчик переключится на 0000h. В каждом байте сначала идёт старший бит данных MSB.
  Восходящий фронт /CS завершает операцию чтения.

  @example
    DataTransmitToFRAM_SPI2 (u_TransmitData.u8_ArrayData, sizeof (g_s_DataFromSensor), 0x5A);
  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef DataReceiveFromFRAM_SPI2 (u8 *u8_p_ReceiveData, u8 u8_SizeOfReceiveData, u16 u16_StartAddressInFRAM)
{

  HAL_StatusTypeDef ReturnStatus;
  u8 u8_a_DataToSend[128] = {0}; // массив для отправки во FRAM стартового адреса
  u8 u8_DataCounter=0;

  //* --------------------------------------- Проверка, включено ли питание FRAM ---------------------------------------------------
  // Читаем из порта его текущее состояние
  if (DRV_FRAM_GPIO_Port->ODR & DRV_FRAM_Pin) // если питание FRAM ВЫКЛючено (порт находится в "1"),...
  {
    // ...ВКЛючаем питание FRAM (сбрасываем линию порта в "0")
    PowerSwitch (FRAM_POWER, POWER_ON);

    // Даём задержку для инициализации по включению питания микросхемы FRAM
    HAL_Delay(15); // согласно Datsheet задержка при ВКЛючении FRAM должна быть не менее 10мс
  }

  //* ------------------------------------ На всякий случай проверяем линию CS2 ---------------------------------------------------
  // если CS2 в "нуле",...
  if ( 0 == (SPI2_CS2_GPIO_Port->ODR & SPI2_CS2_Pin) ) 
  {
    // ... то устанавливаем её в исходное состояние (в "1")
    HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);
    HAL_Delay(1);
  }

  //* -------------------------------------- Читаем данные из FRAM ------------------------------------------------------
  // FM25CL64_READ --> FRAM (команда на чтение данных)
  u8_a_DataToSend[u8_DataCounter++] = FM25CL64_READ;
  // Начальный адрес записи данных во FRAM
  u8_a_DataToSend[u8_DataCounter++] = (u8)((u16_StartAddressInFRAM >> 8) & 0x00ff);
  u8_a_DataToSend[u8_DataCounter++] = (u8)(u16_StartAddressInFRAM & 0x00ff);

  // CS2: "1" --> "0" // стартует фрейм для записи во FRAM
  HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_RESET);

  // Запись данных во FRAM
  // HAL_SPI_Transmit (&hspi2, u8_a_DataToSend, u8_DataCounter, 200);
  if ( HAL_OK != (ReturnStatus = HAL_SPI_TransmitReceive(&hspi2, u8_a_DataToSend, u8_p_ReceiveData, (u16) (u8_SizeOfReceiveData+3), 200) ) )
  {
    HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);
    return ReturnStatus;
  }

  // CS2: "1" --> "0"    Защёлкиваем данные во FRAM
  HAL_GPIO_WritePin(SPI2_CS2_GPIO_Port, SPI2_CS2_Pin, GPIO_PIN_SET);

  return HAL_OK;
}









  /*
  * @brief  Transmit and Receive an amount of data in blocking mode.
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @param  pTxData pointer to transmission data buffer
  * @param  pRxData pointer to reception data buffer
  * @param  Size amount of data to be sent and received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
// HAL_StatusTypeDef HAL_SPI_TransmitReceive(&hspi2, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)








/*********************************** END OF FILE ************************************/
