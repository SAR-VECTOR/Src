/******************** (C) COPYRIGHT 2021 << Weidmueller >> ********************
 * File Name          : HW_I2C.c
 * Author             : Electronic Devices Application Team
 * Version            : V1.01
 * Date               : 12/2021
 * Description        : Управление подпрограммами работы интерфейса IIC
 ********************************************************************************/

// #include <string.h>
// #include <stdarg.h>
// #include <stdio.h>
// #include "HW_Globals.h"
// #include "stm32f0xx_hal_i2c.h"
// #include "HW_I2C.h"

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include "HW_Globals.h"
#include "stm32l1xx_hal_i2c.h"
#include "stm32l1xx_hal_def.h"
#include "HW_I2C.h"

/* Private function prototypes -----------------------------------------------*/
static HAL_StatusTypeDef OLED1_WriteCommandToSSD1306(uint16 u16_Command, ...);

// Прорисовка каждого символа осуществляется слева направо --> сверху вниз (младший разряд вверху, старший - внизу)
uint8 LCD_Buffer[0x500] =
    {
        0x00, 0x00, 0x00, 0x00, 0x00, // 00
        0x00, 0x00, 0x5F, 0x00, 0x00, // 01
        0x00, 0x07, 0x00, 0x07, 0x00, // 02
        0x14, 0x7F, 0x14, 0x7F, 0x14, // 03
        0x24, 0x2A, 0x7F, 0x2A, 0x12, // 04
        0x23, 0x13, 0x08, 0x64, 0x62, // 05
        0x36, 0x49, 0x55, 0x22, 0x50, // 06
        0x00, 0x05, 0x03, 0x00, 0x00, // 07
        0x00, 0x1C, 0x22, 0x41, 0x00, // 08
        0x00, 0x41, 0x22, 0x1C, 0x00, // 09
        0x14, 0x08, 0x3E, 0x08, 0x14, // 0A
        0x08, 0x08, 0x3E, 0x08, 0x08, // 0B
        0x00, 0x50, 0x30, 0x00, 0x00, // 0C
        0x08, 0x08, 0x08, 0x08, 0x08, // 0D
        0x00, 0x60, 0x60, 0x00, 0x00, // 0E
        0x20, 0x10, 0x08, 0x04, 0x02, // 0F

        0x00, 0x00, 0x00, 0x00, 0x00, // 10
        0x00, 0x00, 0x5F, 0x00, 0x00, // 11
        0x00, 0x07, 0x00, 0x07, 0x00, // 12
        0x14, 0x7F, 0x14, 0x7F, 0x14, // 13
        0x24, 0x2A, 0x7F, 0x2A, 0x12, // 14
        0x23, 0x13, 0x08, 0x64, 0x62, // 15
        0x36, 0x49, 0x55, 0x22, 0x50, // 16
        0x00, 0x05, 0x03, 0x00, 0x00, // 17
        0x00, 0x1C, 0x22, 0x41, 0x00, // 18
        0x00, 0x41, 0x22, 0x1C, 0x00, // 19
        0x14, 0x08, 0x3E, 0x08, 0x14, // 1A
        0x08, 0x08, 0x3E, 0x08, 0x08, // 1B
        0x00, 0x50, 0x30, 0x00, 0x00, // 1C
        0x08, 0x08, 0x08, 0x08, 0x08, // 1D
        0x00, 0x60, 0x60, 0x00, 0x00, // 1E
        0x20, 0x10, 0x08, 0x04, 0x02, // 1F

        0x00, 0x00, 0x00, 0x00, 0x00, // 20 space
        0x00, 0x00, 0x5F, 0x00, 0x00, // 21 !
        0x00, 0x07, 0x00, 0x07, 0x00, // 22 "
        0x14, 0x7F, 0x14, 0x7F, 0x14, // 23 #
        0x24, 0x2A, 0x7F, 0x2A, 0x12, // 24 $
        0x23, 0x13, 0x08, 0x64, 0x62, // 25 %
        0x36, 0x49, 0x55, 0x22, 0x50, // 26 &
        0x00, 0x05, 0x03, 0x00, 0x00, // 27 '
        0x00, 0x1C, 0x22, 0x41, 0x00, // 28 (
        0x00, 0x41, 0x22, 0x1C, 0x00, // 29 )
        0x14, 0x08, 0x3E, 0x08, 0x14, // 2a *
        0x08, 0x08, 0x3E, 0x08, 0x08, // 2b +
        0x00, 0x50, 0x30, 0x00, 0x00, // 2c ,
        0x08, 0x08, 0x08, 0x08, 0x08, // 2d -
        0x00, 0x60, 0x60, 0x00, 0x00, // 2e .
        0x20, 0x10, 0x08, 0x04, 0x02, // 2f /

        0x3E, 0x51, 0x49, 0x45, 0x3E, // 30 0
        0x00, 0x42, 0x7F, 0x40, 0x00, // 31 1
        0x42, 0x61, 0x51, 0x49, 0x46, // 32 2
        0x21, 0x41, 0x45, 0x4B, 0x31, // 33 3
        0x18, 0x14, 0x12, 0x7F, 0x10, // 34 4
        0x27, 0x45, 0x45, 0x45, 0x39, // 35 5
        0x3C, 0x4A, 0x49, 0x49, 0x30, // 36 6
        0x01, 0x71, 0x09, 0x05, 0x03, // 37 7
        0x36, 0x49, 0x49, 0x49, 0x36, // 38 8
        0x06, 0x49, 0x49, 0x29, 0x1E, // 39 9
        0x00, 0x36, 0x36, 0x00, 0x00, // 3a :
        0x00, 0x56, 0x36, 0x00, 0x00, // 3b ;
        0x08, 0x14, 0x22, 0x41, 0x00, // 3c <
        0x14, 0x14, 0x14, 0x14, 0x14, // 3d =
        0x00, 0x41, 0x22, 0x14, 0x08, // 3e >
        0x02, 0x01, 0x51, 0x09, 0x06, // 3f ?

        0x32, 0x49, 0x79, 0x41, 0x3E, // 40 @
        0x7E, 0x11, 0x11, 0x11, 0x7E, // 41 A
        0x7F, 0x49, 0x49, 0x49, 0x36, // 42 B
        0x3E, 0x41, 0x41, 0x41, 0x22, // 43 C
        0x7F, 0x41, 0x41, 0x22, 0x1C, // 44 D
        0x7F, 0x49, 0x49, 0x49, 0x41, // 45 E
        0x7F, 0x09, 0x09, 0x09, 0x01, // 46 F
        0x3E, 0x41, 0x49, 0x49, 0x7A, // 47 G
        0x7F, 0x08, 0x08, 0x08, 0x7F, // 48 H
        0x00, 0x41, 0x7F, 0x41, 0x00, // 49 I
        0x20, 0x40, 0x41, 0x3F, 0x01, // 4a J
        0x7F, 0x08, 0x14, 0x22, 0x41, // 4b K
        0x7F, 0x40, 0x40, 0x40, 0x40, // 4c L
        0x7F, 0x02, 0x0C, 0x02, 0x7F, // 4d M
        0x7F, 0x04, 0x08, 0x10, 0x7F, // 4e N
        0x3E, 0x41, 0x41, 0x41, 0x3E, // 4f O

        0x7F, 0x09, 0x09, 0x09, 0x06, // 50 P
        0x3E, 0x41, 0x51, 0x21, 0x5E, // 51 Q
        0x7F, 0x09, 0x19, 0x29, 0x46, // 52 R
        0x46, 0x49, 0x49, 0x49, 0x31, // 53 S
        0x01, 0x01, 0x7F, 0x01, 0x01, // 54 T
        0x3F, 0x40, 0x40, 0x40, 0x3F, // 55 U
        0x1F, 0x20, 0x40, 0x20, 0x1F, // 56 V
        0x3F, 0x40, 0x38, 0x40, 0x3F, // 57 W
        0x63, 0x14, 0x08, 0x14, 0x63, // 58 X
        0x07, 0x08, 0x70, 0x08, 0x07, // 59 Y
        0x61, 0x51, 0x49, 0x45, 0x43, // 5a Z
        0x00, 0x7F, 0x41, 0x41, 0x00, // 5b [
        0x02, 0x04, 0x08, 0x10, 0x20, // 5c обратный слеш
        0x00, 0x41, 0x41, 0x7F, 0x00, // 5d ]
        0x04, 0x02, 0x01, 0x02, 0x04, // 5e ^
        0x40, 0x40, 0x40, 0x40, 0x40, // 5f _

        0x00, 0x01, 0x02, 0x04, 0x00, // 60 `
        0x20, 0x54, 0x54, 0x54, 0x78, // 61 a
        0x7F, 0x48, 0x44, 0x44, 0x38, // 62 b
        0x38, 0x44, 0x44, 0x44, 0x20, // 63 c
        0x38, 0x44, 0x44, 0x48, 0x7F, // 64 d
        0x38, 0x54, 0x54, 0x54, 0x18, // 65 e
        0x08, 0x7E, 0x09, 0x01, 0x02, // 66 f
        0x0C, 0x52, 0x52, 0x52, 0x3E, // 67 g
        0x7F, 0x08, 0x04, 0x04, 0x78, // 68 h
        0x00, 0x44, 0x7D, 0x40, 0x00, // 69 i
        0x20, 0x40, 0x44, 0x3D, 0x00, // 6a j
        0x7F, 0x10, 0x28, 0x44, 0x00, // 6b k
        0x00, 0x41, 0x7F, 0x40, 0x00, // 6c l
        0x7C, 0x04, 0x18, 0x04, 0x78, // 6d m
        0x7C, 0x08, 0x04, 0x04, 0x78, // 6e n
        0x38, 0x44, 0x44, 0x44, 0x38, // 6f o

        0x7C, 0x14, 0x14, 0x14, 0x08, // 70 p
        0x08, 0x14, 0x14, 0x18, 0x7C, // 71 q
        0x7C, 0x08, 0x04, 0x04, 0x08, // 72 r
        0x08, 0x54, 0x54, 0x54, 0x20, // 73 s
        0x04, 0x3F, 0x44, 0x40, 0x20, // 74 t
        0x3C, 0x40, 0x40, 0x20, 0x7C, // 75 u
        0x1C, 0x20, 0x40, 0x20, 0x1C, // 76 v
        0x3C, 0x40, 0x30, 0x40, 0x3C, // 77 w
        0x44, 0x28, 0x10, 0x28, 0x44, // 78 x
        0x0C, 0x50, 0x50, 0x50, 0x3C, // 79 y
        0x44, 0x64, 0x54, 0x4C, 0x44, // 7a z
        0x00, 0x08, 0x36, 0x41, 0x00, // 7b <
        0x00, 0x00, 0x7F, 0x00, 0x00, // 7c |
        0x00, 0x41, 0x36, 0x08, 0x00, // 7d >
        0x10, 0x08, 0x08, 0x10, 0x08, // 7e ~
        0x78, 0x46, 0x41, 0x46, 0x78, // 7f треугольник

                                                 // 4 символа для работы меню:
        0x04, 0x02, 0x3F, 0x02, 0x04, //80 Стрелка вверх
        0x10, 0x20, 0x7E, 0x20, 0x10, //81 Стрелка вниз
        0x01, 0x01, 0x3F, 0x01, 0x01, //82 Упор сверху
        0x40, 0x40, 0x7E, 0x40, 0x40,	//83 Упор снизу
        // 0x00, 0x00, 0x00, 0x00, 0x00, // 80
        // 0x00, 0x00, 0x5F, 0x00, 0x00, // 81
        // 0x00, 0x07, 0x00, 0x07, 0x00, // 82
        // 0x14, 0x7F, 0x14, 0x7F, 0x14, // 83
        0x24, 0x2A, 0x7F, 0x2A, 0x12, // 84
        0x23, 0x13, 0x08, 0x64, 0x62, // 85
        0x36, 0x49, 0x55, 0x22, 0x50, // 86
        0x00, 0x05, 0x03, 0x00, 0x00, // 87
        0x00, 0x1C, 0x22, 0x41, 0x00, // 88
        0x00, 0x41, 0x22, 0x1C, 0x00, // 89
        0x14, 0x08, 0x3E, 0x08, 0x14, // 8A
        0x08, 0x08, 0x3E, 0x08, 0x08, // 8B
        0x00, 0x50, 0x30, 0x00, 0x00, // 8C
        0x08, 0x08, 0x08, 0x08, 0x08, // 8D
        0x00, 0x60, 0x60, 0x00, 0x00, // 8E
        0x20, 0x10, 0x08, 0x04, 0x02, // 8F

        0x00, 0x00, 0x00, 0x00, 0x00, // 90
        0x00, 0x00, 0x5F, 0x00, 0x00, // 91
        0x00, 0x07, 0x00, 0x07, 0x00, // 92
        0x14, 0x7F, 0x14, 0x7F, 0x14, // 93
        0x24, 0x2A, 0x7F, 0x2A, 0x12, // 94
        0x23, 0x13, 0x08, 0x64, 0x62, // 95
        0x36, 0x49, 0x55, 0x22, 0x50, // 96
        0x00, 0x05, 0x03, 0x00, 0x00, // 97
        0x00, 0x1C, 0x22, 0x41, 0x00, // 98
        0x00, 0x41, 0x22, 0x1C, 0x00, // 99
        0x14, 0x08, 0x3E, 0x08, 0x14, // 9A
        0x08, 0x08, 0x3E, 0x08, 0x08, // 9B
        0x00, 0x50, 0x30, 0x00, 0x00, // 9C
        0x08, 0x08, 0x08, 0x08, 0x08, // 9D
        0x00, 0x60, 0x60, 0x00, 0x00, // 9E
        0x20, 0x10, 0x08, 0x04, 0x02, // 9F

        0x00, 0x00, 0x00, 0x00, 0x00, // A0
        0x00, 0x00, 0x5F, 0x00, 0x00, // A1
        0x00, 0x07, 0x00, 0x07, 0x00, // A2
        0x14, 0x7F, 0x14, 0x7F, 0x14, // A3
        0x24, 0x2A, 0x7F, 0x2A, 0x12, // A4
        0x23, 0x13, 0x08, 0x64, 0x62, // A5
        0x36, 0x49, 0x55, 0x22, 0x50, // A6
        0x00, 0x05, 0x03, 0x00, 0x00, // A7
        0x00, 0x1C, 0x22, 0x41, 0x00, // A8
        0x00, 0x41, 0x22, 0x1C, 0x00, // A9
        0x14, 0x08, 0x3E, 0x08, 0x14, // AA
        0x08, 0x08, 0x3E, 0x08, 0x08, // AB
        0x00, 0x50, 0x30, 0x00, 0x00, // AC
        0x08, 0x08, 0x08, 0x08, 0x08, // AD
        0x00, 0x60, 0x60, 0x00, 0x00, // AE
        0x20, 0x10, 0x08, 0x04, 0x02, // AF
        // 0x3E, 0x51, 0x49, 0x45, 0x3E,// B0
        0x00, 0x06, 0x09, 0x09, 0x06, // B0 знак градуса
        0x00, 0x42, 0x7F, 0x40, 0x00, // B1
        0x42, 0x61, 0x51, 0x49, 0x46, // B2
        0x21, 0x41, 0x45, 0x4B, 0x31, // B3
        0x18, 0x14, 0x12, 0x7F, 0x10, // B4
        0x27, 0x45, 0x45, 0x45, 0x39, // B5
        0x3C, 0x4A, 0x49, 0x49, 0x30, // B6
        0x01, 0x71, 0x09, 0x05, 0x03, // B7
        0x36, 0x49, 0x49, 0x49, 0x36, // B8
        0x06, 0x49, 0x49, 0x29, 0x1E, // B9
        0x00, 0x36, 0x36, 0x00, 0x00, // BA
        0x00, 0x56, 0x36, 0x00, 0x00, // BB
        0x08, 0x14, 0x22, 0x41, 0x00, // BC
        0x14, 0x14, 0x14, 0x14, 0x14, // BD
        0x00, 0x41, 0x22, 0x14, 0x08, // BE
        0x02, 0x01, 0x51, 0x09, 0x06, // BF

        // Закомментированый блок альтернативного начертания кириллицы
        // мне оно понравилось меньше, чем в раскомментированном (следующем) блоке

        //  0x7e, 0x11, 0x11, 0x11, 0x7e,//A
        // 	0x7f, 0x49, 0x49, 0x49, 0x33,//Б
        // 	0x7f, 0x49, 0x49, 0x49, 0x36,//В
        // 	0x7f, 0x01, 0x01, 0x01, 0x03,//Г
        // 	0xe0, 0x51, 0x4f, 0x41, 0xff,//Д
        // 	0x7f, 0x49, 0x49, 0x49, 0x41,//E
        // 	0x77, 0x08, 0x7f, 0x08, 0x77,//Ж
        // 	0x41, 0x49, 0x49, 0x49, 0x36,//З
        // 	0x7f, 0x10, 0x08, 0x04, 0x7f,//И
        // 	0x7c, 0x21, 0x12, 0x09, 0x7c,//Й
        // 	0x7f, 0x08, 0x14, 0x22, 0x41,//K
        // 	0x20, 0x41, 0x3f, 0x01, 0x7f,//Л
        // 	0x7f, 0x02, 0x0c, 0x02, 0x7f,//M
        // 	0x7f, 0x08, 0x08, 0x08, 0x7f,//H
        // 	0x3e, 0x41, 0x41, 0x41, 0x3e,//O
        // 	0x7f, 0x01, 0x01, 0x01, 0x7f,//П
        // 	0x7f, 0x09, 0x09, 0x09, 0x06,//P
        // 	0x3e, 0x41, 0x41, 0x41, 0x22,//C
        // 	0x01, 0x01, 0x7f, 0x01, 0x01,//T
        // 	0x47, 0x28, 0x10, 0x08, 0x07,//У
        // 	0x1c, 0x22, 0x7f, 0x22, 0x1c,//Ф
        // 	0x63, 0x14, 0x08, 0x14, 0x63,//X
        // 	0x7f, 0x40, 0x40, 0x40, 0xff,//Ц
        // 	0x07, 0x08, 0x08, 0x08, 0x7f,//Ч
        // 	0x7f, 0x40, 0x7f, 0x40, 0x7f,//Ш
        // 	0x7f, 0x40, 0x7f, 0x40, 0xff,//Щ
        // 	0x01, 0x7f, 0x48, 0x48, 0x30,//Ъ
        // 	0x7f, 0x48, 0x30, 0x00, 0x7f,//Ы
        // 	0x00, 0x7f, 0x48, 0x48, 0x30,//Э
        // 	0x22, 0x41, 0x49, 0x49, 0x3e,//Ь
        // 	0x7f, 0x08, 0x3e, 0x41, 0x3e,//Ю
        // 	0x46, 0x29, 0x19, 0x09, 0x7f,//Я
        // // маленькие буквы
        //  0x20, 0x54, 0x54, 0x54, 0x78,//a
        // 	0x3c, 0x4a, 0x4a, 0x49, 0x31,//б
        // 	0x7c, 0x54, 0x54, 0x28, 0x00,//в
        // 	0x7c, 0x04, 0x04, 0x04, 0x0c,//г
        // 	0xe0, 0x54, 0x4c, 0x44, 0xfc,//д
        // 	0x38, 0x54, 0x54, 0x54, 0x18,//e
        // 	0x6c, 0x10, 0x7c, 0x10, 0x6c,//ж
        // 	0x44, 0x44, 0x54, 0x54, 0x28,//з
        // 	0x7c, 0x20, 0x10, 0x08, 0x7c,//и
        // 	0x7c, 0x41, 0x22, 0x11, 0x7c,//й
        // 	0x7c, 0x10, 0x28, 0x44, 0x00,//к
        // 	0x20, 0x44, 0x3c, 0x04, 0x7c,//л
        // 	0x7c, 0x08, 0x10, 0x08, 0x7c,//м
        // 	0x7c, 0x10, 0x10, 0x10, 0x7c,//н
        // 	0x38, 0x44, 0x44, 0x44, 0x38,//o
        // 	0x7c, 0x04, 0x04, 0x04, 0x7c,//п
        // 	0x7C, 0x14, 0x14, 0x14, 0x08,//p
        // 	0x38, 0x44, 0x44, 0x44, 0x20,//c
        // 	0x04, 0x04, 0x7c, 0x04, 0x04,//т
        // 	0x0C, 0x50, 0x50, 0x50, 0x3C,//у
        // 	0x30, 0x48, 0xfc, 0x48, 0x30,//ф
        // 	0x44, 0x28, 0x10, 0x28, 0x44,//x
        // 	0x7c, 0x40, 0x40, 0x40, 0xfc,//ц
        // 	0x0c, 0x10, 0x10, 0x10, 0x7c,//ч
        // 	0x7c, 0x40, 0x7c, 0x40, 0x7c,//ш
        // 	0x7c, 0x40, 0x7c, 0x40, 0xfc,//щ
        // 	0x04, 0x7c, 0x50, 0x50, 0x20,//ъ
        // 	0x7c, 0x50, 0x50, 0x20, 0x7c,//ы
        // 	0x7c, 0x50, 0x50, 0x20, 0x00,//ь
        // 	0x28, 0x44, 0x54, 0x54, 0x38,//э
        // 	0x7c, 0x10, 0x38, 0x44, 0x38,//ю
        // 	0x08, 0x54, 0x34, 0x14, 0x7c //я

        0x7E, 0x11, 0x11, 0x11, 0x7E, // C0 А
        0x7F, 0x49, 0x49, 0x49, 0x31, // C1 Б
        0x7F, 0x49, 0x49, 0x49, 0x36, // C2 В
        0x7F, 0x01, 0x01, 0x01, 0x03, // C3 Г
        0x60, 0x3E, 0x21, 0x21, 0x7F, // C4 Д
        0x7F, 0x49, 0x49, 0x49, 0x41, // C5 Е
        0x77, 0x08, 0x7F, 0x08, 0x77, // C6 Ж
        0x22, 0x41, 0x49, 0x49, 0x36, // C7 З
        0x7F, 0x10, 0x08, 0x04, 0x7F, // C8 И
        0x7F, 0x10, 0x09, 0x04, 0x7F, // C9 Й
        0x7F, 0x08, 0x14, 0x22, 0x41, // CA К
        0x40, 0x3E, 0x01, 0x01, 0x7F, // CB Л
        0x7F, 0x02, 0x0C, 0x02, 0x7F, // CC М
        0x7F, 0x08, 0x08, 0x08, 0x7F, // CD Н
        0x3E, 0x41, 0x41, 0x41, 0x3E, // CE О
        0x7F, 0x01, 0x01, 0x01, 0x7F, // CF П

        0x7F, 0x09, 0x09, 0x09, 0x06, // D0 Р
        0x3E, 0x41, 0x41, 0x41, 0x22, // D1 С
        0x01, 0x01, 0x7F, 0x01, 0x01, // D2 Т
        0x27, 0x48, 0x48, 0x48, 0x3F, // D3 У
        0x1E, 0x21, 0x7F, 0x21, 0x1E, // D4 Ф
        0x63, 0x14, 0x08, 0x14, 0x63, // D5 Х
        0x3F, 0x20, 0x20, 0x3F, 0x60, // D6 Ц
        0x07, 0x08, 0x08, 0x08, 0x7F, // D7 Ч
        0x7F, 0x40, 0x7F, 0x40, 0x7F, // D8 Ш
        0x3F, 0x20, 0x3F, 0x20, 0x7F, // D9 Щ
        0x01, 0x7F, 0x48, 0x48, 0x30, // DA Ъ
        0x7F, 0x48, 0x30, 0x00, 0x7F, // DB Ы
        0x00, 0x7F, 0x48, 0x48, 0x30, // DC Ь
        0x22, 0x41, 0x49, 0x49, 0x3E, // DD Э
        0x7F, 0x08, 0x3E, 0x41, 0x3E, // DE Ю
        0x46, 0x29, 0x19, 0x09, 0x7F, // DF Я

        0x20, 0x54, 0x54, 0x54, 0x78, // E0 а
        0x3C, 0x4A, 0x4A, 0x4A, 0x30, // E1 б
        0x7C, 0x54, 0x54, 0x28, 0x00, // E2 в
        0x7C, 0x04, 0x04, 0x04, 0x04, // E3 г
        0x60, 0x38, 0x24, 0x24, 0x7C, // E4 д
        0x38, 0x54, 0x54, 0x54, 0x18, // E5 е
        0x6C, 0x10, 0x7C, 0x10, 0x6C, // E6 ж
        0x00, 0x44, 0x54, 0x54, 0x28, // E7 з
        0x7C, 0x20, 0x10, 0x08, 0x7C, // E8 и
        0x7C, 0x21, 0x12, 0x09, 0x7C, // E9 й
        0x7C, 0x10, 0x28, 0x44, 0x00, // EA к
        0x40, 0x38, 0x04, 0x04, 0x7C, // EB л
        0x7C, 0x08, 0x10, 0x08, 0x7C, // EC м
        0x7C, 0x10, 0x10, 0x10, 0x7C, // ED н
        0x38, 0x44, 0x44, 0x44, 0x38, // EE о
        0x7C, 0x04, 0x04, 0x04, 0x7C, // EF п

        0x7C, 0x14, 0x14, 0x14, 0x08, // F0 р
        0x38, 0x44, 0x44, 0x44, 0x00, // F1 с
        0x04, 0x04, 0x7C, 0x04, 0x04, // F2 т
        0x0C, 0x50, 0x50, 0x50, 0x3C, // F3 у
        0x08, 0x14, 0x7C, 0x14, 0x08, // F4 ф
        0x44, 0x28, 0x10, 0x28, 0x44, // F5 х
        0x3C, 0x20, 0x20, 0x3C, 0x60, // F6 ц
        0x0C, 0x10, 0x10, 0x10, 0x7C, // F7 ч
        0x7C, 0x40, 0x7C, 0x40, 0x7C, // F8 ш
        0x3C, 0x20, 0x3C, 0x20, 0x7C, // F9 щ
        0x04, 0x7C, 0x50, 0x50, 0x20, // FA ъ
        0x7C, 0x50, 0x20, 0x00, 0x7C, // FB ы
        0x00, 0x7C, 0x50, 0x50, 0x20, // FC ь
        0x28, 0x44, 0x54, 0x54, 0x38, // FD э
        0x7C, 0x10, 0x38, 0x44, 0x38, // FE ю
        0x48, 0x54, 0x34, 0x14, 0x7C	// FF я
};

/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    OLED1_Clear - Очистка дисплея

  @param    void

  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка
  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef OLED1_Clear(void)
{
  HAL_StatusTypeDef ReturnStatus;
  uint8 a_u8_ClearString[129] = {0};

  a_u8_ClearString[0] = '@'; // первый символ - команда записи данных (0x40)

  // построковый цикл очистки экрана
  for (uint8 u8_Row = 0; u8_Row < 8; u8_Row++)
  {
    OLED1_WriteCommandToSSD1306(3, 0x22, u8_Row, u8_Row); // задаём номер строки
    OLED1_WriteCommandToSSD1306(3, 0x21, 0, 127);					// задаём диапазон столбцов

    // Прописываем подготовленный массив в контроллер дисплея
    ReturnStatus = HAL_I2C_Master_Transmit(&I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_ClearString, 129, I2C_TIMEOUT);

    if (ReturnStatus != HAL_OK)
      return ReturnStatus;
  }
  return HAL_OK;
}


/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    OLED1_ClearOneRow - Очистка одной строки дисплея

  @param    1)uint8       номер очищаемой строки (1...8)

  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка
  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef OLED1_ClearOneRow(uint8 u8_Row)
{
  uint8 a_u8_ClearString[129] = {0};

  // Проверяем размерность входных данных
  if (u8_Row > 8)
    u8_Row = 8;
  if (0 == u8_Row)
    u8_Row = 1;

  u8_Row -= 1;

  // Задаём адрес строки
  OLED1_WriteCommandToSSD1306(3, 0x22, u8_Row, u8_Row);

  // Задаём адрес столбца
  OLED1_WriteCommandToSSD1306(3, 0x21, 0, 127);

  a_u8_ClearString[0] = '@'; // первый символ - команда записи данных (0x40)

  // Прописываем подготовленный массив в контроллер дисплея
  return HAL_I2C_Master_Transmit(&I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_ClearString, 129, I2C_TIMEOUT);
}

/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    OLED1_Font_8x6_printf - Вывод на экран OLED-дисплея, соединенного по интерфейсу IIC (I2C1),
                                        форматированной строки символов (см. printf ANSI C)

  @param    1)u8_Row:       Номер строки (1...8)
  @param    2)u8_Col:       Номер колонки (1...121), до 22 символов на экран
  @param    3)char*,...     Форматированная строка в соответствии с описанием на функцию "printf" (ANSI C)

  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка

  @example
  
  uint8 u8_Value = 123;
  OLED1_Font_8x6_printf (2, 10, "%u", u8_Value );

  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef OLED1_Font_8x6_printf(uint8 u8_Row, uint8 u8_Col, const char *fmt, ...)
{
  va_list args;
  int result;
  char buffer[32] = {0};

  // Загоняем полученные данные в буфер
  va_start(args, fmt);
  result = vsprintf(buffer, fmt, args);
  va_end(args);

  // Если в переданной строке ошибки -> выход
  if (result <= 0)
    return HAL_ERROR;

  // Выводим строку на экран
  return OLED1_PrintFont_8x6(u8_Row, u8_Col, buffer);
}

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_Font_16x12_printf
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Вывод на экран OLED-дисплея, соединенного по интерфейсу IIC (I2C1),
                 |   форматированной строки символов 14x10 (см. printf ANSI C)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      | 1) Номер строки (1...7), при выводе нескольких строк задавать только нечётные строки
                 | 2) Номер колонки (1...116), на строку можно уместить только 10 символов шириной 12 пикс. (NORMAL)
                 | 			или 18 символов шириной 7 пикс. (COMPACT)
                 | 3) Формат вывода символов (NORMAL, INVERSION) - с инверсией или нормальный
                 | 4) Формат вывода символов (NORMAL, COMPACT) - ширина символов
                 | 5) Ссылка на выводимую строку (ptr u8*)
                 |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Example        | uint8 u8_Value = 123;
                 | OLED1_Font_16x12_printf (1, 1, "%3u", u8_Value );
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/

/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    OLED1_Font_16x12_printf - Вывод на экран OLED-дисплея, соединенного по интерфейсу IIC (I2C1),
                                        форматированной строки символов 14x10 (см. printf ANSI C)

  @param    1)u8_Row:       Номер строки (1...7), при выводе нескольких строк задавать только нечётные строки
  @param    2)u8_Col:       Номер колонки (1...116), в пикселях дисплея. На строку можно уместить только 10 символов шириной 12 пикс. (NORMAL)
                              или 18 символов шириной 7 пикс. (COMPACT)
  @param    3)PrintType     Формат вывода символов (NORMAL, INVERSION) - с инверсией или нормальный
  @param    4)FontType      Формат вывода символов (NORMAL, COMPACT) - ширина символов
  @param    5)char*,...     Форматированная строка в соответствии с описанием на функцию "printf" (ANSI C)

  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка

  @example
  
  uint8 u8_Value = 123;
  OLED1_Font_16x12_printf (1, 20, NORMAL, COMPACT, "%3u", u8_Value );
  
  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef OLED1_Font_16x12_printf(uint8 u8_Row, uint8 u8_Col, TYPE_OF_PRINT PrintType, TYPE_OF_PRINT FontType, const char *fmt, ...)
{
  va_list args;
  int result;
  char buffer[32] = {0};

  // Загоняем полученные данные в буфер
  va_start(args, fmt);
  result = vsprintf(buffer, fmt, args);
  va_end(args);

  // Если в переданной строке ошибки -> выход
  if (result <= 0)
    return HAL_ERROR;

  // Выводим строку на экран
  return OLED1_PrintFont_16x12 (u8_Row, u8_Col, PrintType, FontType, buffer);
}

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_Font_56x42_printf
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Вывод на экран OLED-дисплея, соединенного по интерфейсу IIC (I2C1),
                 |   форматированной строки символов (см. printf ANSI C)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      | 1) Номер строки (1...2)
                 | 2) Номер колонки 1...72 (выводится 3 символа, если номер колонки равен 1)
                 | 3) Форматированная строка в соответствии с описанием на функцию "printf" (ANSI C)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Example        | uint8 u8_Value = 123;
                 | OLED1_Font_56x42_printf (1, 1, "%3u", u8_Value );
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
HAL_StatusTypeDef OLED1_Font_56x42_printf(uint8 u8_Row, uint8 u8_Col, const char *fmt, ...)
{
  va_list args;
  int result;
  char buffer[32] = {0};

  // Загоняем полученные данные в буфер
  va_start(args, fmt);
  result = vsprintf(buffer, fmt, args);
  va_end(args);

  // Если в переданной строке ошибки -> выход
  if (result <= 0)
    return HAL_ERROR;

  // Выводим строку на экран
  return OLED1_PrintFont_56x42(u8_Row, u8_Col, buffer);
}

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_PrintFont_8x6
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Вывод на экран ЖК-дисплея , соединенного по интерфейсу IIC (I2C),
                 |   строки символов 7х8
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      | 1) Номер строки (1...8)
                 | 2) Номер колонки (1...121)
                 | 3) Ссылка на выводимую строку (ptr u8*)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
HAL_StatusTypeDef OLED1_PrintFont_8x6(uint8 u8_Row, uint8 u8_Col, char const pu8_InString[])
{
  uint8 a_u8_OutputArray[129] = {0}, u8_ByteCountOfOutputArray = 0, u8_StringLength;

  // Проверка входных данных на размерность
  if (u8_Row > 8)
    u8_Row = 8;
  if (0 == u8_Row)
    u8_Row = 1;
  if (u8_Col > 120)
    u8_Col = 120;
  if (0 == u8_Col)
    u8_Col = 1;

  // Узнаём длину переданной в подпрограмму строки
  u8_StringLength = strlen(pu8_InString);

  // Проверяем длину строки на выход за пределы экрана (макс. 21 символ на строку экрана)
  if ((u8_Col + (u8_StringLength * 8)) > 128)
    u8_StringLength = (uint8)((128 - u8_Col - 1) / 6);

  u8_Row -= 1;				 // расчёт координаты строки
  u8_Col = u8_Col - 1; // расчёт координаты столбца

  // команду на приём дисплеем данных ставим в первый байт выходного массива
  a_u8_OutputArray[u8_ByteCountOfOutputArray++] = '@';

  // цикл по символам входной строки
  for (uint8 u8_Chr = 0; u8_Chr < u8_StringLength; u8_Chr++)
  {
    // прописываем в выходной массив пять байт символа
    for (uint16 u16_NumOfSegment = 0; u16_NumOfSegment < 5; u16_NumOfSegment++)
    {
      // упаковываем символ в выходной массив
      a_u8_OutputArray[u8_ByteCountOfOutputArray++] = (uint8)LCD_Buffer[(uint16)((uint16)(pu8_InString[u8_Chr] * 5) + u16_NumOfSegment)];
    }
    // добавим пробел между символами
    a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0;
  }

  // Проверка величины выходного массива
  if (u8_Col + (u8_ByteCountOfOutputArray - 1) > LCDWIDTH)
  {
    u8_ByteCountOfOutputArray = (LCDWIDTH - u8_Col) + 1;
  }

  // Прописываем адрес строки
  OLED1_WriteCommandToSSD1306(3, 0x22, u8_Row, u8_Row);

  // Прописываем адрес столбца и длину выводимых данных
  OLED1_WriteCommandToSSD1306(3, 0x21, u8_Col, u8_Col + (u8_ByteCountOfOutputArray - 1));

  // Запихиваем подготовленный массив в контроллер дисплея
  return HAL_I2C_Master_Transmit(&I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_OutputArray, u8_ByteCountOfOutputArray, I2C_TIMEOUT);
}

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_PrintFont_16x12
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Вывод строки символов 14х10 на экран ЖК-дисплея, соединенного по интерфейсу IIC (I2C),
                 |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      | 1) Номер строки (1...7), при выводе нескольких строк задавать только нечётные строки
                 | 2) Номер колонки (1...116), на строку можно уместить только 10 символов шириной 12 пикс. (NORMAL)
                 | 			или 18 символов шириной 7 пикс. (COMPACT)
                 | 3) Формат вывода символов (NORMAL, INVERSION) - 
                 | 4) Формат вывода символов (NORMAL, COMPACT) - ширина символов
                 | 5) Ссылка на выводимую строку (ptr u8*)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
HAL_StatusTypeDef OLED1_PrintFont_16x12 (uint8 u8_Row, uint8 u8_Col, TYPE_OF_PRINT PrintType, TYPE_OF_PRINT FontType, char const pu8_InString[])
{
  HAL_StatusTypeDef ReturnStatus;

  uint8 a_u8_OutputArray[129];
  uint8 u8_ByteCountOfOutputArray = 0;
  uint8 u8_Symbol;
  uint8 u8_StringLenght, u8_Bit, u8_R, u8_RightBoard;

  if (COMPACT == FontType) u8_RightBoard = 121;
  else u8_RightBoard = 116;

  // Проверка входных данных на размерность
  if (u8_Row < 1 || u8_Row > 7)
    u8_Row = 1;
  if (u8_Col < 1 || u8_Col > u8_RightBoard)
    u8_Col = 1;

  // команду на приём дисплеем данных ставим в первый байт ВЫХодного массива
  a_u8_OutputArray[0] = 0x40;

  // Узнаём длину переданной в подпрограмму строки
  u8_StringLenght = strlen(pu8_InString);

  if (COMPACT == FontType) u8_RightBoard = 7;
  else u8_RightBoard = 12;

  // Проверяем длину строки на выход за пределы экрана (макс. 21 символ на строку экрана)
  if ((u8_Col + (u8_StringLenght * u8_RightBoard)) > 128)
    u8_StringLenght = (uint8)((128 - u8_Col - 1) / u8_RightBoard);

  u8_Row -= 1;				 // расчёт координаты строки
  u8_Col = u8_Col - 1; // расчёт координаты столбца

  for (u8_R = u8_Row, u8_Bit = 0; u8_R < (u8_Row + 2); u8_R++, u8_Bit += 3) // цикл по строкам
  {
    // очистка ВЫХодного массива
    {
    for (uint8 u8_Cnt = 1; u8_Cnt < 129; u8_Cnt++) 
      a_u8_OutputArray[u8_Cnt] = 0;
    }
    
    // сбрасываем счётчик указателя ВЫХодного массива
    u8_ByteCountOfOutputArray = 1; 

    for (uint8 u8_Chr = 0; u8_Chr < u8_StringLenght; u8_Chr++) // цикл по символам ВХодного массива
    {
      
      // добавим зазор (столбец) между символами
      if (INVERSION == PrintType)
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0xFF;
      else
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0;
        

      for (uint16 u16_NumOfSegment = 0; u16_NumOfSegment < 5; u16_NumOfSegment++) // цикл по горизонтальным сегментам входного символа (5 точек)
      {
        // Рассчитаем адрес сегмента выводимого символа
        u8_Symbol = (uint8)LCD_Buffer[(uint16)((uint16)(pu8_InString[u8_Chr] * 5) + u16_NumOfSegment)];
        u8_Symbol = ((u8_Symbol >> u8_Bit) & 0x0F);

        if (0 == u8_Bit)
        {
          u8_Symbol = (((u8_Symbol & 0x08) << 4) |
                       ((u8_Symbol & 0x04) << 4) | ((u8_Symbol & 0x04) << 3) |
                       ((u8_Symbol & 0x02) << 3) | ((u8_Symbol & 0x02) << 2) |
                       ((u8_Symbol & 0x01) << 2) | ((u8_Symbol & 0x01) << 1));
        }
        else
        {
          u8_Symbol = (((u8_Symbol & 0x08) << 3) | ((u8_Symbol & 0x08) << 2) |
                       ((u8_Symbol & 0x04) << 2) | ((u8_Symbol & 0x04) << 1) |
                       ((u8_Symbol & 0x02) << 1) | ((u8_Symbol & 0x02) << 0) |
                       (u8_Symbol & 0x01));
        }

        // расширяем точку символа 7х5 в удвоенную точку символа 14х10
        //				u8_Symbol =  (((u8_Symbol & 0x08) << 4) | ((u8_Symbol & 0x08) << 3) | \
        //											((u8_Symbol & 0x04) << 3) | ((u8_Symbol & 0x04) << 2) | \
        //											((u8_Symbol & 0x02) << 2) | ((u8_Symbol & 0x02) << 1) | \
        //											((u8_Symbol & 0x01) << 1) | (u8_Symbol & 0x01));

        if (INVERSION == PrintType)
        {
          // и прописываем вычисленную точку в выходной массив с инверсией
          a_u8_OutputArray[u8_ByteCountOfOutputArray++] = ~(u8_Symbol);
          if (FontType == NORMAL) a_u8_OutputArray[u8_ByteCountOfOutputArray++] = ~(u8_Symbol);
        }
        else
        {
          // и прописываем вычисленную точку в выходной массив без инверсии
          a_u8_OutputArray[u8_ByteCountOfOutputArray++] = u8_Symbol;
          if (FontType == NORMAL) a_u8_OutputArray[u8_ByteCountOfOutputArray++] = u8_Symbol;
        }
      }

      // добавим зазор (столбец) между символами
      if (INVERSION == PrintType)
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0xFF;
      else
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0;

    } // цикл по символам входного массива

    // Прописываем адрес строки
    OLED1_WriteCommandToSSD1306(3, 0x22, (uint8)(u8_R), (uint8)(u8_R));

    // Прописываем адрес первого столбца и длину выводимых данных
    OLED1_WriteCommandToSSD1306(3, 0x21, u8_Col, u8_Col + (u8_ByteCountOfOutputArray - 1));

    // Проверка величины выходного массива
    if (u8_Col + (u8_ByteCountOfOutputArray - 1) > LCDWIDTH)
    {
      u8_ByteCountOfOutputArray = (LCDWIDTH - u8_Col) + 1;
    }

    // for (uint8 i=1; i< u8_ByteCountOfOutputArray; i++)
    // 	a_u8_OutputArray [i] = ~a_u8_OutputArray [i];

    // Запихиваем подготовленный массив в контроллер дисплея
    ReturnStatus = HAL_I2C_Master_Transmit(&I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_OutputArray, u8_ByteCountOfOutputArray, I2C_TIMEOUT);

    // Если ошибка при выводе на дисплей, выход
    if (HAL_OK != ReturnStatus)
      return ReturnStatus;

  } // цикл по строкам

  return HAL_OK;
}





/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_NegativePrintFont_16x12
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Вывод строки символов 14х10 на экран ЖК-дисплея, соединенного по интерфейсу IIC (I2C),
                 |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      | 1) Номер строки (1...7), при выводе нескольких строк задавать только нечётные строки
                 | 2) Номер колонки (1...116), на строку можно уместить только 10 символов шириной 12 пикс.
                 | 3) Ссылка на выводимую строку (ptr u8*)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
HAL_StatusTypeDef OLED1_NegativePrintFont_16x12(uint8 u8_Row, uint8 u8_Col, char const pu8_InString[])
{
  HAL_StatusTypeDef ReturnStatus;

  uint8 a_u8_OutputArray[129];
  uint8 u8_ByteCountOfOutputArray = 0;
  uint8 u8_Symbol;
  uint8 u8_StringLenght, u8_Bit, u8_R;

  // Проверка входных данных на размерность
  if (u8_Row < 1 || u8_Row > 7)
    u8_Row = 1;
  if (u8_Col < 1 || u8_Col > 116)
    u8_Col = 1;

  // команду на приём дисплеем данных ставим в первый байт ВЫХодного массива
  a_u8_OutputArray[0] = 0x40;

  // Узнаём длину переданной в подпрограмму строки
  u8_StringLenght = strlen(pu8_InString);

  // Проверяем длину строки на выход за пределы экрана (макс. 21 символ на строку экрана)
  if ((u8_Col + (u8_StringLenght * 12)) > 128)
    u8_StringLenght = (uint8)((128 - u8_Col - 1) / 12);

  u8_Row -= 1;				 // расчёт координаты строки
  u8_Col = u8_Col - 1; // расчёт координаты столбца

  for (u8_R = u8_Row, u8_Bit = 0; u8_R < (u8_Row + 2); u8_R++, u8_Bit += 3) // цикл по строкам
  {

    for (uint8 u8_Cnt = 1; u8_Cnt < 129; u8_Cnt++) // очистка ВЫХодного массива
    {
      a_u8_OutputArray[u8_Cnt] = 0;
    }

    u8_ByteCountOfOutputArray = 1; // сбрасываем счётчик указателя ВЫХодного массива

    for (uint8 u8_Chr = 0; u8_Chr < u8_StringLenght; u8_Chr++) // цикл по символам ВХодного массива
    {
      for (uint16 u16_NumOfSegment = 0; u16_NumOfSegment < 5; u16_NumOfSegment++) // цикл по горизонтальным сегментам входного символа (5 точек)
      {
        // Рассчитаем адрес сегмента выводимого символа
        u8_Symbol = (uint8)LCD_Buffer[(uint16)((uint16)(pu8_InString[u8_Chr] * 5) + u16_NumOfSegment)];
        u8_Symbol = ((u8_Symbol >> u8_Bit) & 0x0F);

        // расширяем точку символа 7х5 в удвоенную точку символа 14х10
        //				u8_Symbol =  (((u8_Symbol & 0x08) << 4) | ((u8_Symbol & 0x08) << 3) | \
//											((u8_Symbol & 0x04) << 3) | ((u8_Symbol & 0x04) << 2) | \
//											((u8_Symbol & 0x02) << 2) | ((u8_Symbol & 0x02) << 1) | \
//											((u8_Symbol & 0x01) << 1) | (u8_Symbol & 0x01));

        // расширяем точку символа 7х5 в удвоенную точку символа 14х10

        if (0 == u8_Bit)
        {
          u8_Symbol = (((u8_Symbol & 0x08) << 4) |
                       ((u8_Symbol & 0x04) << 4) | ((u8_Symbol & 0x04) << 3) |
                       ((u8_Symbol & 0x02) << 3) | ((u8_Symbol & 0x02) << 2) |
                       ((u8_Symbol & 0x01) << 2) | ((u8_Symbol & 0x01) << 1));
        }
        else
        {
          u8_Symbol = (((u8_Symbol & 0x08) << 3) | ((u8_Symbol & 0x08) << 2) |
                       ((u8_Symbol & 0x04) << 2) | ((u8_Symbol & 0x04) << 1) |
                       ((u8_Symbol & 0x02) << 1) | ((u8_Symbol & 0x02) << 0) |
                       (u8_Symbol & 0x01));
        }

        // и прописываем вычисленную точку в выходной массив
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = ~(u8_Symbol);
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = ~(u8_Symbol);
      }

      // добавим зазор (двухпиксельный столбец) между символами
      a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0xFF;
      a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0xFF;

    } // цикл по символам входного массива

    // Прописываем адрес строки
    OLED1_WriteCommandToSSD1306(3, 0x22, (uint8)(u8_R), (uint8)(u8_R));

    // Прописываем адрес первого столбца и длину выводимых данных
    OLED1_WriteCommandToSSD1306(3, 0x21, u8_Col, u8_Col + (u8_ByteCountOfOutputArray - 1));

    // Проверка величины выходного массива
    if (u8_Col + (u8_ByteCountOfOutputArray - 1) > LCDWIDTH)
    {
      u8_ByteCountOfOutputArray = (LCDWIDTH - u8_Col) + 1;
    }

    // for (uint8 i=1; i< u8_ByteCountOfOutputArray; i++)
    // 	a_u8_OutputArray [i] = ~a_u8_OutputArray [i];

    // Запихиваем подготовленный массив в контроллер дисплея
    ReturnStatus = HAL_I2C_Master_Transmit(&I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_OutputArray, u8_ByteCountOfOutputArray, I2C_TIMEOUT);

    // Если ошибка при выводе на дисплей, выход
    if (HAL_OK != ReturnStatus)
      return ReturnStatus;

  } // цикл по строкам

  return HAL_OK;
}

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_PrintFont_56x42
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Вывод строки символов 56х40 на экран ЖК-дисплея, соединенного по интерфейсу IIC (I2C),
                 |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      | 1) Номер строки (1...2)
                 | 2) Номер колонки (1...72)
                 | 3) Ссылка на выводимую строку (ptr u8*)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
HAL_StatusTypeDef OLED1_PrintFont_56x42(uint8 u8_Row, uint8 u8_Col, char const pu8_InString[])
{
  uint8 a_u8_OutputArray[129];
  uint8 u8_ByteCountOfOutputArray = 0;
  uint8 u8_Symbol;
  uint8 u8_StringLenght, u8_Bit, u8_R;

  // Проверка входных данных на размерность
  if (u8_Row < 1 || u8_Row > 2)
    u8_Row = 1;
  if (u8_Col > 72)
    u8_Col = 1;
  if (0 == u8_Col)
    u8_Col = 1;

  // команду на приём дисплеем данных ставим в первый байт ВЫХодного массива
  a_u8_OutputArray[0] = 0x40;

  // Узнаём длину переданной в подпрограмму строки
  u8_StringLenght = strlen(pu8_InString);

  // Проверяем длину строки на выход за пределы экрана (макс. 21 символ на строку экрана)
  if ((u8_Col + (u8_StringLenght * 42)) > 128)
    u8_StringLenght = (uint8)((128 - u8_Col - 1) / 42);

  u8_Row -= 1;								// расчёт координаты строки
  u8_Col = (u8_Col - 1) * 42; // расчёт координаты столбца

  for (u8_R = u8_Row, u8_Bit = 0; u8_R < (u8_Row + 7); u8_R++, u8_Bit++) // цикл по строкам
  {

    for (uint8 u8_Cnt = 1; u8_Cnt < 129; u8_Cnt++) // очистка ВЫХодного массива
    {
      a_u8_OutputArray[u8_Cnt] = 0;
    }

    u8_ByteCountOfOutputArray = 1; // сбрасываем счётчик указателя ВЫХодного массива

    for (uint8 u8_Chr = 0; u8_Chr < u8_StringLenght; u8_Chr++) // цикл по символам ВХодного массива
    {
      for (uint16 u16_NumOfSegment = 0; u16_NumOfSegment < 5; u16_NumOfSegment++) // цикл по горизонтальным сегментам символа (5 точек)
      {
        // Рассчитаем адрес сегмента выводимого символа
        u8_Symbol = (uint8)LCD_Buffer[(uint16)((uint16)(pu8_InString[u8_Chr] * 5) + u16_NumOfSegment)];
        u8_Symbol = ((u8_Symbol >> u8_Bit) & 0x01);

        for (uint8 u8_Octal = 0; u8_Octal < 8; u8_Octal++) // цикл по 8 точкам большого символа (соответствует одной точке маленького)
        {
          if (u8_Symbol)
            a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0xFF;
          else
            a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0;
        }
      }

      // добавим пробел между символами
      if (u8_Chr != (u8_StringLenght - 1))
      {
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0;
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0;
        a_u8_OutputArray[u8_ByteCountOfOutputArray++] = 0;
      }

    } // цикл по символам входного массива

    // Прописываем адрес строки
    OLED1_WriteCommandToSSD1306(3, 0x22, u8_R, u8_R);

    // Прописываем адрес первого столбца и длину выводимых данных
    OLED1_WriteCommandToSSD1306(3, 0x21, u8_Col, u8_Col + (u8_ByteCountOfOutputArray - 1));

    // Проверка величины выходного массива
    if (u8_Col + (u8_ByteCountOfOutputArray - 1) > LCDWIDTH)
    {
      u8_ByteCountOfOutputArray = (LCDWIDTH - u8_Col) + 1;
    }

    // Запихиваем подготовленный массив в контроллер дисплея
    HAL_I2C_Master_Transmit(&I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_OutputArray, u8_ByteCountOfOutputArray, I2C_TIMEOUT);

  } // цикл по строкам

  return HAL_OK;
}

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_WriteCommandToSSD1306
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Отправка команды в контроллер OLED дисплея по интерфейсу IIC1 (I2C1)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      | 1) uint16 - количество байтов, передаваемых в контроллер этой командой (не считая команду!)
                 | 2) uint16 - через запятую команды управления контроллером дисплея
                 |		(количество команд задано первым аргументом)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
static HAL_StatusTypeDef OLED1_WriteCommandToSSD1306(uint16 u16_Command, ...)
{
  uint8 a_u8_DataArray[10], i = 0;

  // Чистим служебный массив, заполняем нейтральными командами
  for (uint8 a = 0; a < 10; a++)
    a_u8_DataArray[a] = OLED_NOP;

  a_u8_DataArray[i++] = OLED_COMMAND; // Говорим контроллеру (прописывая в массив), что следующие байты - команды

  va_list uk_arg; // инициализируем набор параметров (аргументы функции)

  // установка указателя uk_arg на первый параметр (аргумент) функции
  va_start(uk_arg, u16_Command);

  // Заполняем служебный массив командами (аргументами функции)
  for (uint16 k = 0; k < u16_Command; k++)
  {
    // т.к. аргументы двухбайтные, приводим их к однобайтному варианту
    a_u8_DataArray[i++] = (uint8)va_arg(uk_arg, unsigned int);
  }

  va_end(uk_arg); /* закрытие списка параметров   */

  // Отправляем массив в контроллер
  return HAL_I2C_Master_Transmit(&I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_DataArray, i, I2C_TIMEOUT);
}

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_WriteDataToController
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Отправка данных в контроллер OLED дисплея по интерфейсу IIC1 (I2C1)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         | Возвращаемые константы:
                 | HAL_OK 			всё в норме
                 | HAL_ERROR  	ошибка
                 | HAL_BUSY   	ошибка
                 | HAL_TIMEOUT	ошибка
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
// static HAL_StatusTypeDef OLED1_WriteDataToController (uint8 u8_Command)
// {
// 	uint8 a_u8_CommandArray [2];

// 	a_u8_CommandArray [0] = OLED1_DATA;
// 	a_u8_CommandArray [1] = u8_Command;

// 	return HAL_I2C_Master_Transmit ( &I2C1_Struct, OLED1_WRITE_7BIT_ADDRESS, a_u8_CommandArray, sizeof (a_u8_CommandArray), I2C_TIMEOUT );
// }

/*——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  Function Name  |  OLED1_Init
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Description    | • Инициализация OLED ЖК-дисплея, соединенного по интерфейсу IIC1 (I2C1)
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Arguments      |
—————————————————+——————————————————————————————————————————————————————————————————————————————————————————————
  Return         |
                 |
———————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
void OLED1_Init(void)
{
  // выключаем изображение, чтобы не мигало при инициализации
  OLED1_WriteCommandToSSD1306(1, DISPLAYOFF);

  OLED1_WriteCommandToSSD1306(2, SETDISPLAYCLOCKDIV, 0x80);

  OLED1_WriteCommandToSSD1306(2, SETMULTIPLEX, 0x3F);

  OLED1_WriteCommandToSSD1306(2, SETDISPLAYOFFSET, 0x00);

  OLED1_WriteCommandToSSD1306(1, (SETSTARTLINE | 0x00)); // 0

  // We use internal charge pump
  OLED1_WriteCommandToSSD1306(2, CHARGE_PUMP, CHARGEPUMP_ENABLE);

  // Horizontal memory mode
  OLED1_WriteCommandToSSD1306(2, MEMORY_MODE, HORIZONTAL_ADDR);

  OLED1_WriteCommandToSSD1306(1, NORMAL_SEG_REMAP);

  OLED1_WriteCommandToSSD1306(1, COM_SCAN_DEC);

  OLED1_WriteCommandToSSD1306(2, SETCOMPINS, 0x12);

  // Set contrast
  OLED1_WriteCommandToSSD1306(2, SETCONTRAST, OLED_DEFAULT_CONTRAST);

  OLED1_WriteCommandToSSD1306(2, SETPRECHARGE, 0xF1);

  OLED1_WriteCommandToSSD1306(2, SETVCOMDETECT, 0x40);

  OLED1_WriteCommandToSSD1306(1, DISPLAYALLON_RESUME);

  // Non-inverted display
  OLED1_WriteCommandToSSD1306(1, NORMALDISPLAY);

  // Включаем изображение
  OLED1_WriteCommandToSSD1306(1, DISPLAYON);
}



// Другие варианты начертания букв для OLED:

//  0x7e, 0x11, 0x11, 0x11, 0x7e,//A	0x80
// 	0x7f, 0x49, 0x49, 0x49, 0x33,//Б	0x81
// 	0x7f, 0x49, 0x49, 0x49, 0x36,//В	0x82
// 	0x7f, 0x01, 0x01, 0x01, 0x03,//Г	0x83
// 	0xe0, 0x51, 0x4f, 0x41, 0xff,//Д	0x84
// 	0x7f, 0x49, 0x49, 0x49, 0x41,//E	0x85
// 	0x77, 0x08, 0x7f, 0x08, 0x77,//Ж	0x86
// 	0x41, 0x49, 0x49, 0x49, 0x36,//З	0x87
// 	0x7f, 0x10, 0x08, 0x04, 0x7f,//И	0x88
// 	0x7c, 0x21, 0x12, 0x09, 0x7c,//Й	0x89
// 	0x7f, 0x08, 0x14, 0x22, 0x41,//K	0x8A
// 	0x20, 0x41, 0x3f, 0x01, 0x7f,//Л	0x8B
// 	0x7f, 0x02, 0x0c, 0x02, 0x7f,//M	0x8C
// 	0x7f, 0x08, 0x08, 0x08, 0x7f,//H	0x8D
// 	0x3e, 0x41, 0x41, 0x41, 0x3e,//O	0x8E
// 	0x7f, 0x01, 0x01, 0x01, 0x7f,//П	0x8F
// 	0x7f, 0x09, 0x09, 0x09, 0x06,//P	0x90
// 	0x3e, 0x41, 0x41, 0x41, 0x22,//C	0x91
// 	0x01, 0x01, 0x7f, 0x01, 0x01,//T	0x92
// 	0x47, 0x28, 0x10, 0x08, 0x07,//У	0x93
// 	0x1c, 0x22, 0x7f, 0x22, 0x1c,//Ф	0x94
// 	0x63, 0x14, 0x08, 0x14, 0x63,//X	0x95
// 	0x7f, 0x40, 0x40, 0x40, 0xff,//Ц	0x96
// 	0x07, 0x08, 0x08, 0x08, 0x7f,//Ч	0x97
// 	0x7f, 0x40, 0x7f, 0x40, 0x7f,//Ш	0x98
// 	0x7f, 0x40, 0x7f, 0x40, 0xff,//Щ	0x99
// 	0x01, 0x7f, 0x48, 0x48, 0x30,//Ъ	0x9A
// 	0x7f, 0x48, 0x30, 0x00, 0x7f,//Ы	0x9B
// 	0x00, 0x7f, 0x48, 0x48, 0x30,//Э	0x9C
// 	0x22, 0x41, 0x49, 0x49, 0x3e,//Ь	0x9D
// 	0x7f, 0x08, 0x3e, 0x41, 0x3e,//Ю	0x9E
// 	0x46, 0x29, 0x19, 0x09, 0x7f,//Я	0x9F
// // маленькие буквы
//  	0x20, 0x54, 0x54, 0x54, 0x78,//a	0xA0
// 	0x3c, 0x4a, 0x4a, 0x49, 0x31,//б	0xA1
// 	0x7c, 0x54, 0x54, 0x28, 0x00,//в	0xA2
// 	0x7c, 0x04, 0x04, 0x04, 0x0c,//г	0xA3
// 	0xe0, 0x54, 0x4c, 0x44, 0xfc,//д	0xA4
// 	0x38, 0x54, 0x54, 0x54, 0x18,//e	0xA5
// 	0x6c, 0x10, 0x7c, 0x10, 0x6c,//ж	0xA6
// 	0x44, 0x44, 0x54, 0x54, 0x28,//з	0xA7
// 	0x7c, 0x20, 0x10, 0x08, 0x7c,//и	0xA8
// 	0x7c, 0x41, 0x22, 0x11, 0x7c,//й	0xA9
// 	0x7c, 0x10, 0x28, 0x44, 0x00,//к	0xAA
// 	0x20, 0x44, 0x3c, 0x04, 0x7c,//л	0xAB
// 	0x7c, 0x08, 0x10, 0x08, 0x7c,//м	0xAC
// 	0x7c, 0x10, 0x10, 0x10, 0x7c,//н	0xAD
// 	0x38, 0x44, 0x44, 0x44, 0x38,//o	0xAE
// 	0x7c, 0x04, 0x04, 0x04, 0x7c,//п	0xAF
// 	0x7C, 0x14, 0x14, 0x14, 0x08,//p 	0xB0
// 	0x38, 0x44, 0x44, 0x44, 0x20,//c	0xB1
// 	0x04, 0x04, 0x7c, 0x04, 0x04,//т	0xB2
// 	0x0C, 0x50, 0x50, 0x50, 0x3C,//у	0xB3
// 	0x30, 0x48, 0xfc, 0x48, 0x30,//ф	0xB4
// 	0x44, 0x28, 0x10, 0x28, 0x44,//x	0xB5
// 	0x7c, 0x40, 0x40, 0x40, 0xfc,//ц	0xB6
// 	0x0c, 0x10, 0x10, 0x10, 0x7c,//ч	0xB7
// 	0x7c, 0x40, 0x7c, 0x40, 0x7c,//ш	0xB8
// 	0x7c, 0x40, 0x7c, 0x40, 0xfc,//щ	0xB9
// 	0x04, 0x7c, 0x50, 0x50, 0x20,//ъ	0xBA
// 	0x7c, 0x50, 0x50, 0x20, 0x7c,//ы	0xBB
// 	0x7c, 0x50, 0x50, 0x20, 0x00,//ь	0xBC
// 	0x28, 0x44, 0x54, 0x54, 0x38,//э	0xBD
// 	0x7c, 0x10, 0x38, 0x44, 0x38,//ю	0xBE
// 	0x08, 0x54, 0x34, 0x14, 0x7c, //я	0xBF

// 	0x00, 0x00, 0x00, 0x00, 0x00,// (space)
// 	0x00, 0x00, 0x5F, 0x00, 0x00,// !
// 	0x00, 0x07, 0x00, 0x07, 0x00,// "
// 	0x14, 0x7F, 0x14, 0x7F, 0x14,// #
// 	0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
// 	0x23, 0x13, 0x08, 0x64, 0x62,// %
// 	0x36, 0x49, 0x55, 0x22, 0x50,// &
// 	0x00, 0x05, 0x03, 0x00, 0x00,// '
// 	0x00, 0x1C, 0x22, 0x41, 0x00,// (
// 	0x00, 0x41, 0x22, 0x1C, 0x00,// )
// 	0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
// 	0x08, 0x08, 0x3E, 0x08, 0x08,// +
// 	0x00, 0x50, 0x30, 0x00, 0x00,// ,
// 	0x08, 0x08, 0x08, 0x08, 0x08,// -
// 	0x00, 0x60, 0x60, 0x00, 0x00,// .
// 	0x20, 0x10, 0x08, 0x04, 0x02,// /
// 	0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
// 	0x00, 0x42, 0x7F, 0x40, 0x00,// 1
// 	0x42, 0x61, 0x51, 0x49, 0x46,// 2
// 	0x21, 0x41, 0x45, 0x4B, 0x31,// 3
// 	0x18, 0x14, 0x12, 0x7F, 0x10,// 4
// 	0x27, 0x45, 0x45, 0x45, 0x39,// 5
// 	0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
// 	0x01, 0x71, 0x09, 0x05, 0x03,// 7
// 	0x36, 0x49, 0x49, 0x49, 0x36,// 8
// 	0x06, 0x49, 0x49, 0x29, 0x1E,// 9
// 	0x00, 0x36, 0x36, 0x00, 0x00,// :
// 	0x00, 0x56, 0x36, 0x00, 0x00,// ;
// 	0x00, 0x08, 0x14, 0x22, 0x41,// <
// 	0x14, 0x14, 0x14, 0x14, 0x14,// =
// 	0x41, 0x22, 0x14, 0x08, 0x00,// >
// 	0x02, 0x01, 0x51, 0x09, 0x06,// ?
// 	0x32, 0x49, 0x79, 0x41, 0x3E,// @
// 	0x7E, 0x11, 0x11, 0x11, 0x7E,// A
// 	0x7F, 0x49, 0x49, 0x49, 0x36,// B
// 	0x3E, 0x41, 0x41, 0x41, 0x22,// C
// 	0x7F, 0x41, 0x41, 0x22, 0x1C,// D
// 	0x7F, 0x49, 0x49, 0x49, 0x41,// E
// 	0x7F, 0x09, 0x09, 0x01, 0x01,// F
// 	0x3E, 0x41, 0x41, 0x51, 0x32,// G
// 	0x7F, 0x08, 0x08, 0x08, 0x7F,// H
// 	0x00, 0x41, 0x7F, 0x41, 0x00,// I
// 	0x20, 0x40, 0x41, 0x3F, 0x01,// J
// 	0x7F, 0x08, 0x14, 0x22, 0x41,// K
// 	0x7F, 0x40, 0x40, 0x40, 0x40,// L
// 	0x7F, 0x02, 0x04, 0x02, 0x7F,// M
// 	0x7F, 0x04, 0x08, 0x10, 0x7F,// N
// 	0x3E, 0x41, 0x41, 0x41, 0x3E,// O
// 	0x7F, 0x09, 0x09, 0x09, 0x06,// P
// 	0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
// 	0x7F, 0x09, 0x19, 0x29, 0x46,// R
// 	0x46, 0x49, 0x49, 0x49, 0x31,// S
// 	0x01, 0x01, 0x7F, 0x01, 0x01,// T
// 	0x3F, 0x40, 0x40, 0x40, 0x3F,// U
// 	0x1F, 0x20, 0x40, 0x20, 0x1F,// V
// 	0x7F, 0x20, 0x18, 0x20, 0x7F,// W
// 	0x63, 0x14, 0x08, 0x14, 0x63,// X
// 	0x03, 0x04, 0x78, 0x04, 0x03,// Y
// 	0x61, 0x51, 0x49, 0x45, 0x43,// Z
// 	0x00, 0x00, 0x7F, 0x41, 0x41,// [
// 	0x02, 0x04, 0x08, 0x10, 0x20,// "\"
// 	0x41, 0x41, 0x7F, 0x00, 0x00,// ]
// 	0x04, 0x02, 0x01, 0x02, 0x04,// ^
// 	0x40, 0x40, 0x40, 0x40, 0x40,// _
// 	0x00, 0x01, 0x02, 0x04, 0x00,// `
// 	0x20, 0x54, 0x54, 0x54, 0x78,// a
// 	0x7F, 0x48, 0x44, 0x44, 0x38,// b
// 	0x38, 0x44, 0x44, 0x44, 0x20,// c
// 	0x38, 0x44, 0x44, 0x48, 0x7F,// d
// 	0x38, 0x54, 0x54, 0x54, 0x18,// e
// 	0x08, 0x7E, 0x09, 0x01, 0x02,// f
// 	0x08, 0x14, 0x54, 0x54, 0x3C,// g
// 	0x7F, 0x08, 0x04, 0x04, 0x78,// h
// 	0x00, 0x44, 0x7D, 0x40, 0x00,// i
// 	0x20, 0x40, 0x44, 0x3D, 0x00,// j
// 	0x00, 0x7F, 0x10, 0x28, 0x44,// k
// 	0x00, 0x41, 0x7F, 0x40, 0x00,// l
// 	0x7C, 0x04, 0x18, 0x04, 0x78,// m
// 	0x7C, 0x08, 0x04, 0x04, 0x78,// n
// 	0x38, 0x44, 0x44, 0x44, 0x38,// o
// 	0x7C, 0x14, 0x14, 0x14, 0x08,// p
// 	0x08, 0x14, 0x14, 0x18, 0x7C,// q
// 	0x7C, 0x08, 0x04, 0x04, 0x08,// r
// 	0x48, 0x54, 0x54, 0x54, 0x20,// s
// 	0x04, 0x3F, 0x44, 0x40, 0x20,// t
// 	0x3C, 0x40, 0x40, 0x20, 0x7C,// u
// 	0x1C, 0x20, 0x40, 0x20, 0x1C,// v
// 	0x3C, 0x40, 0x30, 0x40, 0x3C,// w
// 	0x44, 0x28, 0x10, 0x28, 0x44,// x
// 	0x0C, 0x50, 0x50, 0x50, 0x3C,// y
// 	0x44, 0x64, 0x54, 0x4C, 0x44,// z
// 	0x00, 0x08, 0x36, 0x41, 0x00,// {
// 	0x00, 0x00, 0x7F, 0x00, 0x00,// |
// 	0x00, 0x41, 0x36, 0x08, 0x00,// }
// 	0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
// 	0x08, 0x1C, 0x2A, 0x08, 0x08, // <-

// 	0x7E, 0x11, 0x11, 0x11, 0x7E,// A
// 	0x7F, 0x49, 0x49, 0x49, 0x30,// Б
// 	0x7F, 0x49, 0x49, 0x49, 0x36,// B
// 	0x7F, 0x01, 0x01, 0x01, 0x01,// Г
// 	0x60, 0x3F, 0x21, 0x3F, 0x60,// Д
// 	0x7F, 0x49, 0x49, 0x49, 0x41,// E
// 	0x63, 0x14, 0x7F, 0x14, 0x63,// Ж
// 	0x49, 0x49, 0x49, 0x49, 0x36,// З
// 	0x7F, 0x10, 0x08, 0x04, 0x7F,// И
// 	0x7F, 0x10, 0x09, 0x04, 0x7F,// Й
// 	0x7F, 0x08, 0x14, 0x22, 0x41,// К
// 	0x40, 0x3F, 0x01, 0x01, 0x7F,// Л
// 	0x7F, 0x02, 0x04, 0x02, 0x7F,// М
// 	0x7F, 0x08, 0x08, 0x08, 0x7F,// H
// 	0x3E, 0x41, 0x41, 0x41, 0x3E,// O
// 	0x7F, 0x01, 0x01, 0x01, 0x7F,// П
// 	0x7F, 0x09, 0x09, 0x09, 0x06,// P
// 	0x3E, 0x41, 0x41, 0x41, 0x22,// C
// 	0x01, 0x01, 0x7F, 0x01, 0x01,// T
// 	0x63, 0x14, 0x08, 0x04, 0x03,// У
// 	0x3E, 0x41, 0x7F, 0x41, 0x3E,// Ф
// 	0x63, 0x14, 0x08, 0x14, 0x63,// X
// 	0x3F, 0x20, 0x20, 0x3F, 0x60,// Ц
// 	0x07, 0x08, 0x08, 0x08, 0x7F,// Ч
// 	0x7F, 0x40, 0x7F, 0x40, 0x7F,// Ш
// 	0x3F, 0x20, 0x3F, 0x20, 0x7F,// Щ
// 	0x01, 0x7F, 0x48, 0x48, 0x30,// Ъ
// 	0x3C, 0x41, 0x42, 0x20, 0x7C,// ?
// 	0x7F, 0x08, 0x3E, 0x41, 0x3E,// Ю
// 	0x46, 0x29, 0x19, 0x09, 0x7F,// Я

// 	0x20, 0x54, 0x54, 0x54, 0x78,// а
// 	0x7E, 0x49, 0x45, 0x45, 0x39,// б
// 	0x7C, 0x54, 0x54, 0x58, 0x20,// в
// 	0x7C, 0x04, 0x04, 0x04, 0x04,// г
// 	0x08, 0x14, 0x54, 0x54, 0x3C,// д
// 	0x38, 0x54, 0x54, 0x54, 0x18,// е
// 	0x44, 0x28, 0x7C, 0x28, 0x44,// ж
// 	0x54, 0x54, 0x54, 0x54, 0x28,// з
// 	0x3C, 0x40, 0x40, 0x20, 0x7C,// и
// 	0x3C, 0x41, 0x42, 0x21, 0x7C,// й
// 	0x00, 0x7C, 0x10, 0x28, 0x44,// к
// 	0x40, 0x3C, 0x04, 0x04, 0x7C,// л
// 	0x7C, 0x08, 0x10, 0x08, 0x7C,// м
// 	0x00, 0x7C, 0x10, 0x10, 0x7C,// н
// 	0x38, 0x44, 0x44, 0x44, 0x38,// о
// 	0x00, 0x7C, 0x04, 0x04, 0x7C,// п
// 	0x7C, 0x14, 0x14, 0x14, 0x08,// р
// 	0x38, 0x44, 0x44, 0x44, 0x20,// с
// 	0x04, 0x04, 0x7C, 0x04, 0x04,// т
// 	0x0C, 0x50, 0x50, 0x50, 0x3C,// у
// 	0x38, 0x44, 0x7C, 0x44, 0x38,// ф
// 	0x44, 0x28, 0x10, 0x28, 0x44,// х
// 	0x3C, 0x20, 0x20, 0x3C, 0x60,// ц
// 	0x00, 0x0C, 0x10, 0x10, 0x7C,// ч
// 	0x7C, 0x40, 0x7C, 0x40, 0x7C,// ш
// 	0x3C, 0x20, 0x3C, 0x20, 0x7C,// щ
// 	0x04, 0x7C, 0x50, 0x50, 0x30,// ъ
// 	0x00, 0x7C, 0x50, 0x50, 0x30,// ь
// 	0x7C, 0x10, 0x38, 0x44, 0x38,// ю
// 	0x48, 0x34, 0x14, 0x14, 0x7C // я
// };

// uint8 LCD_CyrBuffer[320] =
// {
//  	0x7e, 0x11, 0x11, 0x11, 0x7e,//A	0x80
// 	0x7f, 0x49, 0x49, 0x49, 0x33,//Б	0x81
// 	0x7f, 0x49, 0x49, 0x49, 0x36,//В	0x82
// 	0x7f, 0x01, 0x01, 0x01, 0x03,//Г	0x83
// 	0xe0, 0x51, 0x4f, 0x41, 0xff,//Д	0x84
// 	0x7f, 0x49, 0x49, 0x49, 0x41,//E	0x85
// 	0x77, 0x08, 0x7f, 0x08, 0x77,//Ж	0x86
// 	0x41, 0x49, 0x49, 0x49, 0x36,//З	0x87
// 	0x7f, 0x10, 0x08, 0x04, 0x7f,//И	0x88
// 	0x7c, 0x21, 0x12, 0x09, 0x7c,//Й	0x89
// 	0x7f, 0x08, 0x14, 0x22, 0x41,//K	0x8A
// 	0x20, 0x41, 0x3f, 0x01, 0x7f,//Л	0x8B
// 	0x7f, 0x02, 0x0c, 0x02, 0x7f,//M	0x8C
// 	0x7f, 0x08, 0x08, 0x08, 0x7f,//H	0x8D
// 	0x3e, 0x41, 0x41, 0x41, 0x3e,//O	0x8E
// 	0x7f, 0x01, 0x01, 0x01, 0x7f,//П	0x8F
// 	0x7f, 0x09, 0x09, 0x09, 0x06,//P	0x90
// 	0x3e, 0x41, 0x41, 0x41, 0x22,//C	0x91
// 	0x01, 0x01, 0x7f, 0x01, 0x01,//T	0x92
// 	0x47, 0x28, 0x10, 0x08, 0x07,//У	0x93
// 	0x1c, 0x22, 0x7f, 0x22, 0x1c,//Ф	0x94
// 	0x63, 0x14, 0x08, 0x14, 0x63,//X	0x95
// 	0x7f, 0x40, 0x40, 0x40, 0xff,//Ц	0x96
// 	0x07, 0x08, 0x08, 0x08, 0x7f,//Ч	0x97
// 	0x7f, 0x40, 0x7f, 0x40, 0x7f,//Ш	0x98
// 	0x7f, 0x40, 0x7f, 0x40, 0xff,//Щ	0x99
// 	0x01, 0x7f, 0x48, 0x48, 0x30,//Ъ	0x9A
// 	0x7f, 0x48, 0x30, 0x00, 0x7f,//Ы	0x9B
// 	0x00, 0x7f, 0x48, 0x48, 0x30,//Э	0x9C
// 	0x22, 0x41, 0x49, 0x49, 0x3e,//Ь	0x9D
// 	0x7f, 0x08, 0x3e, 0x41, 0x3e,//Ю	0x9E
// 	0x46, 0x29, 0x19, 0x09, 0x7f,//Я	0x9F
// // маленькие буквы
//  	0x20, 0x54, 0x54, 0x54, 0x78,//a	0xA0
// 	0x3c, 0x4a, 0x4a, 0x49, 0x31,//б	0xA1
// 	0x7c, 0x54, 0x54, 0x28, 0x00,//в	0xA2
// 	0x7c, 0x04, 0x04, 0x04, 0x0c,//г	0xA3
// 	0xe0, 0x54, 0x4c, 0x44, 0xfc,//д	0xA4
// 	0x38, 0x54, 0x54, 0x54, 0x18,//e	0xA5
// 	0x6c, 0x10, 0x7c, 0x10, 0x6c,//ж	0xA6
// 	0x44, 0x44, 0x54, 0x54, 0x28,//з	0xA7
// 	0x7c, 0x20, 0x10, 0x08, 0x7c,//и	0xA8
// 	0x7c, 0x41, 0x22, 0x11, 0x7c,//й	0xA9
// 	0x7c, 0x10, 0x28, 0x44, 0x00,//к	0xAA
// 	0x20, 0x44, 0x3c, 0x04, 0x7c,//л	0xAB
// 	0x7c, 0x08, 0x10, 0x08, 0x7c,//м	0xAC
// 	0x7c, 0x10, 0x10, 0x10, 0x7c,//н	0xAD
// 	0x38, 0x44, 0x44, 0x44, 0x38,//o	0xAE
// 	0x7c, 0x04, 0x04, 0x04, 0x7c,//п	0xAF
// 	0x7C, 0x14, 0x14, 0x14, 0x08,//p 	0xB0
// 	0x38, 0x44, 0x44, 0x44, 0x20,//c	0xB1
// 	0x04, 0x04, 0x7c, 0x04, 0x04,//т	0xB2
// 	0x0C, 0x50, 0x50, 0x50, 0x3C,//у	0xB3
// 	0x30, 0x48, 0xfc, 0x48, 0x30,//ф	0xB4
// 	0x44, 0x28, 0x10, 0x28, 0x44,//x	0xB5
// 	0x7c, 0x40, 0x40, 0x40, 0xfc,//ц	0xB6
// 	0x0c, 0x10, 0x10, 0x10, 0x7c,//ч	0xB7
// 	0x7c, 0x40, 0x7c, 0x40, 0x7c,//ш	0xB8
// 	0x7c, 0x40, 0x7c, 0x40, 0xfc,//щ	0xB9
// 	0x04, 0x7c, 0x50, 0x50, 0x20,//ъ	0xBA
// 	0x7c, 0x50, 0x50, 0x20, 0x7c,//ы	0xBB
// 	0x7c, 0x50, 0x50, 0x20, 0x00,//ь	0xBC
// 	0x28, 0x44, 0x54, 0x54, 0x38,//э	0xBD
// 	0x7c, 0x10, 0x38, 0x44, 0x38,//ю	0xBE
// 	0x08, 0x54, 0x34, 0x14, 0x7c //я	0xBF
// };

/*********************************** END OF FILE ************************************/
