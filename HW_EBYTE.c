/******************** (C) COPYRIGHT 2022 < VECTOR >********************
* File Name          : HW_EBYTE.c
* Author             : Electronic Devices Application Team
* Version            : V1.01
* Date               : 11/2022
* Description        : Подпрограммы управления обменом информации по радиоканалу
********************************************************************************/


/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32l1xx_it.h"
#include "HW_Globals.h"
#include "HW_UART.h"
#include "HW_POWER.h"
#include "HW_EBYTE.h"

/* Private includes ----------------------------------------------------------*/
/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/


	// _Save = _Params[0];
	// _AddressHigh = _Params[1];
	// _AddressLow = _Params[2];
	// _Speed = _Params[3];
	// _Channel = _Params[4];
	// _Options = _Params[5];

	// _Address =  (_AddressHigh << 8) | (_AddressLow);
	// _ParityBit = (_Speed & 0XC0) >> 6;
	// _UARTDataRate = (_Speed & 0X38) >> 3;
	// _AirDataRate = _Speed & 0X07;

	// _OptionTrans = (_Options & 0X80) >> 7;
	// _OptionPullup = (_Options & 0X40) >> 6;
	// _OptionWakeup = (_Options & 0X38) >> 3;
	// _OptionFEC = (_Options & 0X07) >> 2;
	// _OptionPower = (_Options & 0X03);


/* Private function prototypes -----------------------------------------------*/
/* Private user code ---------------------------------------------------------*/
/* External variables --------------------------------------------------------*/
extern UART_HandleTypeDef huart2; // Заполненная данными после инициализации порта структура данных для UART2 (main.c)


/*********************************************************************************************************************************************************
                                              Разделение диапазонов частот обмена
Дефолтные (обязательные ) каналы
868.9 MHz	  MultiSF   125 kHz	          100мВт	    Рабочий цикл 10% или режим LBT (LBT (Listening Before Transmitting) - прослушивание канала перед передачей)
869.1 MHz	  MultiSF   125 kHz	          100мВт	    Рабочий цикл 10% или режим LBT
864.6 MHz	  SF7       250 kHz	          25мВт	      LoraSTD, без ограничений
864.8 MHz	  FSK       250 kHz, 50kbps	  25мВт	      FSK, без ограничений
869.1 MHz	  SF12      125 kHz	          25мВт       RX2, без ограничений

Дополнительные каналы
866.1 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
866.3 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
866.5 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
866.7 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
866.9 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
867.1 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
867.3 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
867.5 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
867.7 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT
867.9 MHz	  MultiSF   125 kHz	          25мВт	      Запрещается использование в пределах аэропортов (аэродромов), Рабочий цикл 1% или режим LBT


   -----------   Теория работы: ---------------------------------------------------------
  1. Выход AUX

    При включении питания модуля E32-900T20S выход AUX немедленно выдает сигнал низкого уровня, выполняет аппаратную самопроверку и устанавливает
режим работы, основанный на запрограммированных в RF-модуль параметрах пользователя. В ходе инициализации AUX остается на низком уровне.
После завершения инициализации вывод AUX выдает высокий уровень и RF-модуль начинает работать в соответствии с режимом работы,
установленным с помощью линий M1 и M0. Поэтому мастеру необходимо дождаться начала нормальной работы RF-модуля после окончания инициализации.

    Выход AUX может использоваться в качестве индикации для буфера беспроводной передачи, а также индикации приема и индикации инициализации.
Он может указывать, действительно ли есть данные, которые еще не отправлены беспроводным способом, действительно ли все беспроводные данные были
переданы через UART, действительно ли модуль все еще находится в процессе инициализации/самопроверки.

Буфер (пустой): данные размером 512 байт (ёмкость буфера) записываются в RFIC (Radio Frequency Integrated Circuit) c использованием автоупаковки.
Когда AUX = 1, пользователь может вводить данные не более 512 байт непрерывно, не боясь переполнения.
** Когда AUX = 1, это не означает, что все данные UART модуля уже переданы, возможно, самый последний пакет данных все еще находится в процессе передачи!

Буфер (не пустой): когда AUX=0, внутренние данные в 512 байт в буфере не были записаны в RFIC полностью (идёт процесс освобождения буфера).
Если пользователь начнет передавать данные при таких обстоятельствах, это может привести к тому,
что со временем модуль будет ожидать пользовательских данных или передавать беспроводной вспомогательный пакет (что бы это значило?(SAR)).

**Итак: данные лучше всего передавать в E32-900T20S в случае когда AUX = 1 !!!!
----------------------------------------------------------------------------------------
2. Входы M0 и M1

    Существует четыре режима работы, которые устанавливаются с помощью линий M1 и M0:

    Mode?0-3)  M0  M1

    0 Normal    0   0   UART и беспроводной канал открыты, включена прозрачная передача (Приемник должен работать в режиме 0 или режиме 1)

    1 Wake up   1   0   UART и беспроводной канал открыты, единственное отличие от режима 0 заключается в том, что перед передачей данных
                            автоматически увеличивается код пробуждения, чтобы он мог разбудить приемник в режиме 3
                                (Приемник может работать в режимах 0, 1 или 2)
    
    2 Power     0   1   UART закрывается, беспроводная связь находится в режиме ожидания пробуждения по каналу беспроводной связи,
    saving                   после получения данных UART открывается и отправляет данные.

    3 Sleep     1   1   спящий режим, доступны команды настройки параметров приема.

    Пользователь может выбрать режим работы с помощью комбинации M1 и M0. Две линии GPIO MCU можно использовать для
переключения режима. После изменения M1 или M0 RF-модуль начнет работать в новом режиме через 1 мс, если RF-модуль свободен. Если есть
какие-либо последовательные данные, которые еще не завершили беспроводную передачу, то RF-модуль начнёт работать в новом режиме после завершения
передачи UART. После того, как RF-модуль получит беспроводные данные и передаст их через последовательный порт, он
начнет работать в новом режиме после завершения передачи. Следовательно, переключатель режимов действителен только при AUX = 1,
в противном случае это приведет к задержке.
    Например, в режиме 0 или режиме 1, если пользователь последовательно вводит массив данных и одновременно переключает режим работы, операция
переключения режимов недопустима. Проверка нового режима может быть запущена только после завершения обработки всех пользовательских данных.
Рекомендуется проверить состояние вывода AUX и подождать 2 мс после выхода AUX на высокий уровень, прежде чем переключать режим.
    Если модуль переключается из других режимов в режим ожидания, он будет работать в режиме ожидания только после завершения
обработки всех оставшихся данных. Эта функция может быть использована для экономии энергопотребления.
Например, когда передатчик работает в режиме 0, после того, как внешний микроконтроллер передает данные “12345”,
он может немедленно переключиться в спящий режим, не дожидаясь появления "единицы" на выходе AUX, микроконтроллер пользователя
немедленно переходит в спящий режим. Затем модуль передаст все данные по беспроводной связи и автоматически перейдет в режим ожидания через 1 мс,
что сократит время работы MCU пользователя и сэкономит электроэнергию.
Аналогично, эта функция может быть использована при любом переключении режимов. Модуль начнет работать в новом режиме в течение 1 мс после
завершения задачи текущего режима, что позволяет пользователю пропустить процедуру запроса состояния AUX и быстро переключить режим.
Например, при переключении из режима передачи в режим приема пользовательский микроконтроллер может перейти в режим ожидания перед переключением режима,
используя функцию внешнего прерывания для получения изменения AUX, чтобы можно было реализовать переключение режима.

---------------------------------------------------------------------------------------
3. Режимы работы

  Normal mode (mode 0) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  M1 = 0 & M0 = 0

	Передача данных (Tx)
	В этом режиме RF-модуль может принимать пользовательские данные через UART и передавать беспроводной пакет данных объемом 58 байт.
	Когда объем введенных пользователем данных достигнет 58 байт, модуль начнет беспроводную передачу, в течение которой пользователь может
непрерывно продолжать вводить данные для передачи.
Когда требуемые байты передачи составляют менее 58 байт, модуль будет ждать 3-байтовое время и рассматривать это как
завершение передачи данных, если пользователь не начнёт снова вводить непрерывные данные. Затем модуль передаст все данные по беспроводному
каналу.
Когда модуль получает первый пакет данных от пользователя, AUX выдает низкий уровень. После того, как все данные переданы в радиочастотный
чип и передача началась, AUX выводит высокий уровень. В это время это означает, что запущена последняя передача беспроводного пакета данных,
что позволяет пользователю непрерывно ввести еще 512 байт.
**Пакет данных, переданный от модуля, работающего в режиме 0, может быть принят только модулем, работающим в режиме 0 или 1.

	Приём данных (Rx)
	В режиме 0 функция беспроводного приема модуля включена, пакет данных, переданный от модуля, работающего в режиме 0 и
режиме 1, может быть принят мастером. После получения пакета данных AUX переключается на низкий уровень,
через 5 мс модуль начинает передавать мастеру полученные беспроводные данные через последовательный порт линии TXD.
После того, как все беспроводные данные были переданы через последовательный порт, AUX выдает высокий уровень.



	Wake-up mode (mode 1) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	M1 = 0 & M0 = 1

	Передача данных (Tx)
	Условия передачи пакетов данных и функции работы линии AUX такие же, как в режиме 0. Единственное отличие заключается в том, что
модуль автоматически добавляет код преамбулы перед каждым пакетом данных. Длина кода преамбулы зависит от времени
пробуждения, установленного в пользовательских параметрах. Целью кода преамбулы является пробуждение приемного модуля,
работающего в режиме 2.
Следовательно, 
**пакет данных, переданный из режима 1, может быть принят режимом 0, режимом 1 и режимом 2.

	Приём данных (Rx)
	То же, что и в режиме 0.



	Power-saving mode (mode 2) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	M1 = 1 & M0 = 0

	Передача данных (Tx)
	UART закрыт, модуль не может получать какие-либо данные последовательного порта извне от мастера. Следовательно,
функция беспроводной передачи недоступна для модуля, работающего в этом режиме.


	Приём данных (Rx)
	В режиме 2 требуется, чтобы передатчик данных работал в режиме 1. Беспроводной модуль отслеживает код преамбулы в эфире.
Как только он получит код преамбулы, он останется в статусе получения и будет ожидать завершения получения
всего действительного пакета данных. Затем AUX выводит низкий уровень, через 5 мс последовательный порт открыт для передачи
принятых беспроводных данных через TXD. Наконец, AUX выводит высокий уровень после завершения процесса.
Беспроводной модуль остается в рабочем состоянии “энергосбережение – мониторинг” (опрос).
Установив разное время пробуждения, модуль будет иметь различную задержку ответа на прием (максимум 2 секунды) и
среднее энергопотребление (минимум 30 мкА).
Пользователю необходимо достичь баланса между временем задержки связи и средним энергопотреблением.



	Sleep mode (mode 3) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	M1 = 1 & M0 = 1

	Приём и передача невозможны.
	Этот режим можно использовать для настройки параметров.
	Он использует последовательный порт при скорости 9600 и 8N1 для установки рабочих параметров модуля с помощью
определенного формата инструкций. Когда режим переключается со спящего режима ожидания на другие, модуль сбрасывает свои параметры,
во время чего AUX сохраняет низкий уровень, а затем выводит высокий уровень после завершения сброса.
Рекомендуется проверить повышающий край AUX мастеру.


---------------------------------------------------------------------------------------
4. Формат комманд

В спящем режиме (режим 3: M1 = 1, M0 = 1) поддерживаются приведенные ниже инструкции (9600, 8N1)

1) < 0xC0 + working parameters >
	Рабочие параметры C0 + 5 байт отправляются в шестнадцатеричном формате. Всего 6 байт, и они должны быть отправлены последовательно
	(параметры сохраняются при выключении питания).

2) < 0xC1+0xC1+0xC1 >
	Три 0xC1 отправляются в шестнадцатеричном формате. Модуль возвращает сохраненные параметры, отправляемые последовательно.

	Например:
	Default parameter values:C0 00 00 1A 17 44

	Model 			  Frequency   Address   Channel   Air data rate   Baud rate   Parity 	  Transmitting power
	E32-900T20S   868MHz 		  0x0000 	  0x06 		  2.4kbps 			  9600 			  8N1 		  100mW

Формат команды:
___________________________________________________________________________________________________________________________________________
Номер байта        Элемент                         Описание
___________________________________________________________________________________________________________________________________________
0                  Заголовок команды               0xC0 — при выключении питания модуля параметры сохраняются;
                                                   0xC2  — при выключении питания модуля параметры не сохраняются (удобно для тестирования);

1                  Адрес, старший байт             Значения от 0x00 до 0xFF

2                  Адрес, младший байт             Значения от 0x00 до 0xFF

3                  Формат данных UART, скорость передачи данных
                                                   Биты 7, 6 — режим работы порта UART
                                                   Биты 5, 4, 3 — скорость передачи данных через UART
                                                   Биты 2, 1, 0 — скорость передачи данных по радиоканалу

4                  Номер канала передачи данных    Значения от 0x00 до 0x1F

5                  Дополнительные параметры конфигурации
                                                   Бит 7 — прозрачный или фиксированный режим передачи данных
                                                   Бит 6 — используется ли подтягивающий резистор (1 — используется, 
                                                             0 – не используется, схема с открытым коллектором)
                                                   Биты 5, 4, 3 — задержка пробуждения модуля при получении данных по радиоканалу
                                                   Бит 2 — если равен 1, 
                                                             используется режим упреждающей коррекции ошибок FEC (Forward Error Correction),
                                                             если 0 — этот режим отключен
                                                   Биты 1, 0 — выходная мощность радиомодуля
____________________________________________________________________________________________________________________________________________



3) < 0xC2 + working parameters >
	Рабочие параметры C2 + 5 байт отправляются в шестнадцатеричном формате. Все 6 байт должны быть отправлены последовательно.
	(Не сохраняется при выключении питания).

4) < 0xC3+0xC3+0xC3 >
	Три C3 отправляются в шестнадцатеричном формате. Модуль возвращает информацию о версии.

	Например: C3 00 45 0A 14 0B XX YY.
	Третий байт означает частоту. 45 здесь означает частоту 900 МГц, 0x14 означает мощность 20 дБм;
	xx - номер версии, а yy относится к другим функциям модуля.

5) < 0xC4+0xC4+0xC4 >
	Три C4 отправляются в шестнадцатеричном формате. Модуль будет сброшен один раз.
	Во время процесса сброса модуль проведет самопроверку, AUX выводит низкий уровень. После завершения сброса AUX выдает высокий уровень,
	затем модуль начинает работать в нормальном режиме, после чего рабочий режим может быть переключен или дана другая инструкция.


**********************************************************************************************************************************************************/










/** ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  @brief    TransmitDataToRFmodule_E32_900T20S - отправка данных для беспроводной передачи через RF-модуль.
                                                      Канал и адрес должны быть установлены заранее (до начала передачи данных).

  @param    1)*p_u8_pData:                указатель на массив передаваемых данных
  @param    2)u16_DataSize:               размер передаваемых данных в байтах
  
  @property

  @retval   HAL_OK: 	  всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HAL_StatusTypeDef TransmitDataToRFmodule_E32_900T20S (u8 *p_u8_pData, u16 u16_DataSize)
{
  HAL_StatusTypeDef ReturnStatus;
  u32 u32_WaitingTimeCounter;

  u16 u16_NumberOfDataParts; // Количество пакетов данных по "SIZE_OF_ONE_PART_OF_TRANSMIT_DATA" байт (переменная (но не константа) может быть равна нулю)
  u16 u16_RemainderOfDataIsNotMultipleOfPart; // остаток данных, не вошедший в пакеты данных, кратные "SIZE_OF_ONE_PART_OF_TRANSMIT_DATA" байтам

  // Чтобы избежать деления на ноль, проверяем значение
  ASSERT (0 != u16_DataSize);
  ASSERT (0 != SIZE_OF_ONE_PART_OF_TRANSMIT_DATA);
  if (0 == SIZE_OF_ONE_PART_OF_TRANSMIT_DATA || 0 == u16_DataSize)
    return HAL_ERROR;

  // Узнаём, сколько у нас целых пакетов данных по "SIZE_OF_ONE_PART_OF_TRANSMIT_DATA" байт.
  // Допускается, что не наберётся и одного такого пакета (в случае u16_DataSize < SIZE_OF_ONE_PART_OF_TRANSMIT_DATA).
  u16_NumberOfDataParts = (u8) (u16_DataSize / (u16) SIZE_OF_ONE_PART_OF_TRANSMIT_DATA);

  // Узнаём, сколько байт данных останется после пересылки в RF-модуль целых пакетов данных
  // Если даже на один целый пакет данных не набралось, то тогда в этой переменной будет лежать окончательное число передаваемых байт.
  u16_RemainderOfDataIsNotMultipleOfPart = u16_DataSize % (u16) SIZE_OF_ONE_PART_OF_TRANSMIT_DATA;

  // Включение питания модуля и установка режима передачи данных
  SetOperatingModeRFmodule_E32_900T20S (MODE_NORMAL); // питание включается (если было выключено) внутри этой процедуры

  // Цикл по количеству целых пакетов. Отправляем данные:
  for (u16 u16_PartCounter=0; u16_PartCounter < u16_NumberOfDataParts; u16_PartCounter++)
  {
    // Ожидание освобождения буфера RF-модуля
    // Настраиваем значение счётчика ожидания
    u32_WaitingTimeCounter = HAL_GetTick() + AUX_TIMEOUT_BEFORE_MODE_SWITCH;

    // Цикл ожидания переключение сигнала AUX (от RF-модуля) в "1"
    while (LOW == HAL_GPIO_ReadPin(E32_AUX_GPIO_Port, E32_AUX_Pin))
    {
      if (HAL_GetTick() > u32_WaitingTimeCounter)
      { // Выход из процедуры по завершении времени ожидания переключения сигнала AUX
        return HAL_TIMEOUT;
      }
    }

    // Если дождались готовности буфера RF-модуля принять наши данные (AUX=1), передаём их
    if (HAL_OK != (ReturnStatus = HAL_UART_Transmit(&huart2,
                                                      &p_u8_pData[u16_PartCounter * SIZE_OF_ONE_PART_OF_TRANSMIT_DATA],
                                                        (u16) SIZE_OF_ONE_PART_OF_TRANSMIT_DATA,
                                                          TIME_OUT_OF_TRANSMITTER_UART2)))
    {
      return ReturnStatus; // в случае ошибки выходим с передачей стстуса ошибки
    }                                                          
  }
  
  // Отправляем оставшиеся (не кратные размеру пакета) данные

  // Ожидание освобождения буфера RF-модуля
  // Настраиваем значение счётчика ожидания
  u32_WaitingTimeCounter = HAL_GetTick() + AUX_TIMEOUT_BEFORE_MODE_SWITCH;

  // Цикл ожидания переключение сигнала AUX (от RF-модуля) в "1"
  while (LOW == HAL_GPIO_ReadPin(E32_AUX_GPIO_Port, E32_AUX_Pin))
  {
    if (HAL_GetTick() > u32_WaitingTimeCounter)
    { // Выход из процедуры по завершении времени ожидания переключения сигнала AUX
      return HAL_TIMEOUT;
    }
  }

  // Если дождались готовности буфера RF-модуля принять данные (AUX=1), передаём их
  if (HAL_OK != (ReturnStatus = HAL_UART_Transmit(&huart2,
                                                    &p_u8_pData[u16_NumberOfDataParts * SIZE_OF_ONE_PART_OF_TRANSMIT_DATA],
                                                      u16_RemainderOfDataIsNotMultipleOfPart,
                                                        TIME_OUT_OF_TRANSMITTER_UART2)))
  {
    return ReturnStatus; // в случае ошибки выходим с передачей стстуса ошибки
  }                                                          

  return HAL_OK; // Если всё передать удалось без ошибок, возвращаем OK
}










/** ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  @brief    SetOperatingModeRFmodule_E32_900T20S - Установка режима работы высокочастотного (RF) модуля
                              с предварительным ВКЛючением его питания (если питание RF-модуля было ВЫКЛючено, то оно ВКЛючится в этой процедуре)

  @param    1)OperatingMode:            константа режима работы Operating_Mode:
                                              MODE_NORMAL				       can send and recieve
                                              MODE_WAKEUP				       sends a preamble to waken receiver
                                              MODE_POWERDOWN				   can't transmit but receive works only in wake up mode
                                              MODE_PROGRAM				     for programming
  @property
  ВНИМАНИЕ!!! Процедура ВКЛючает (если было ВЫКЛюченным) питание RF-модуля, а при выходе НЕ ВЫКЛючает (питание остаётся ВКЛючённым))!!!!!

  @return 	SWITCHED_MODE_NORMALLY,				            переключение выполнено
            NO_AUX_OUTPUT_AFTER_POWER_ON,				      ошибка, сигнал AUX у RF-модуля не переключился в "0" после включения питания
            NO_AUX_OUTPUT_BEFORE_MODE_SWITCHING				ошибка, сигнал AUX у RF-модуля не переключился в "0" перед переключением режима

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
Return_Status_After_Operating_Changes    SetOperatingModeRFmodule_E32_900T20S (Operating_Mode OperatingMode)
{
  u32 u32_WaitingTimeCounter;

  PowerSwitch (RF_MODULE_POWER, POWER_ON); // включаем питание EBYTE

  // Настраиваем значение счётчика ожидания
  u32_WaitingTimeCounter = HAL_GetTick() + AUX_TIMEOUT_AFTER_POWER_ON;

  // Цикл ожидания переключение сигнала AUX (от RF-модуля) в "1"
  while (LOW == HAL_GPIO_ReadPin(E32_AUX_GPIO_Port, E32_AUX_Pin))
  {
    if (HAL_GetTick() > u32_WaitingTimeCounter)
    { // Выход из процедуры по завершении времени ожидания сигнала AUX
      return NO_AUX_OUTPUT_AFTER_POWER_ON;
    }
  }

  HAL_Delay(5); // задержка (рекомендуется изготовителем) на переключение AUX и последующее ожидание переключения режима работы
  
  // Дождались спада сигнала AUX и выполняем переключение режима работы:
  switch (OperatingMode)
  {
  case MODE_NORMAL:
    HAL_GPIO_WritePin(E32_M0_GPIO_Port, E32_M0_Pin, LOW);
    HAL_GPIO_WritePin(E32_M1_GPIO_Port, E32_M1_Pin, LOW);
    break;

  case MODE_WAKEUP:
    HAL_GPIO_WritePin(E32_M0_GPIO_Port, E32_M0_Pin, HIGH);
    HAL_GPIO_WritePin(E32_M1_GPIO_Port, E32_M1_Pin, LOW);
    break;

  case MODE_POWERDOWN:
    HAL_GPIO_WritePin(E32_M0_GPIO_Port, E32_M0_Pin, LOW);
    HAL_GPIO_WritePin(E32_M1_GPIO_Port, E32_M1_Pin, HIGH);
    break;

  case MODE_PROGRAM:
    HAL_GPIO_WritePin(E32_M0_GPIO_Port, E32_M0_Pin, HIGH);
    HAL_GPIO_WritePin(E32_M1_GPIO_Port, E32_M1_Pin, HIGH);
    break;

  }
  
  HAL_Delay(PIN_RECOVER); // задержка на изменение режима работы в модуле

  return SWITCHED_MODE_NORMALLY;

}





//* Установка параметров RF-модуля через UART2
/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    SetParametersOfRFmodule - Отправка параметров в RF-модуль через UART2

  @param    1) Saving_Parameters_When_Power_Down:       Судьба параметров модуля после исчезновения питания.
                  SAVE_THE_PARAMETERS_WHEN_POWER_DOWN  -  При отключении питания параметры сохранятся в памяти модуля
                  DO_NOT_SAVE_THE_PARAMETERS_WHEN_POWER_DOWN  -  При отключении питания параметры сбросятся в записанные ранее в памяти модуля

  @param    2) UART_Baud_Rate:                          Скорость обмена между МК и RF-модулем в битах в секунду.
                  UART_BAUD_RATE_1200bps
                  UART_BAUD_RATE_2400bps
                  UART_BAUD_RATE_4800bps
                  UART_BAUD_RATE_9600bps
                  UART_BAUD_RATE_19200bps
                  UART_BAUD_RATE_38400bps
                  UART_BAUD_RATE_57600bps
                  UART_BAUD_RATE_115200bps

  @param    3) UART_Parity_Bit:        формат посылки данных при обмене по UART
                  UART_8N1 - 8 бит данных с одним стоповым
                  UART_8O1 - 8 бит данных, бит наличия НЕчётности, стоповый бит
                  UART_8E1 - 8 бит данных, бит наличия чётности, стоповый бит

  @param    4) u16_WirelessDeviceAddress:        Адрес приёмника назначения.
                  Исключения: 0 или 0xFFFF - широковещательный режим (принимает приёмник с любым собственным адресом).

  @param    5) Air_Baud_Rate:        Скорость обмена по беспроводному каналу.
                  AIR_BAUD_RATE_300bps
                  AIR_BAUD_RATE_1200bps
                  AIR_BAUD_RATE_2400bps
                  AIR_BAUD_RATE_4800bps
                  AIR_BAUD_RATE_9600bps
                  AIR_BAUD_RATE_19200bps

  @param    6) Wireless_Channel:        Канал беспроводного обмена.
                  CHANNEL_6_FREQUENCY_868_MHZ - Частота беспроводного канала 868 Мгц (канал 6)
                  CHANNEL_7_FREQUENCY_869_MHZ - Частота беспроводного канала 869 Мгц (канал 7)

  @param    7) Transmission_Mode:        Режим передачи данных по беспроводному каналу.
                  TRANSPARENT TRANSMISSION MODE - Широковещательный режим (все приёмники могут принимать данное сообщение)
                  FIXED TRANSMISSION MODE = 0x80 - Фиксированный режим (первые байты сообщения содержат адрес приёмника, который должен принять сообщение)

  @param    8) Type_Of_Inputs_Outputs:        Варианты работы выходов (открытый коллектор или обычный выход) и входов (утянутый или плавающий) RF-модуля. 
                  OPEN_COLLECTOR_OUTPUTS_AND_FLOAT_INPUTS - ВЫХоды RF-модуля работают с открытым коллектором, ВХоды не утянуты к цепям питания
                  PUSH_PULL_OUTPUTS_AND_PULL_UP_INPUTS - ВЫХоды RF-модуля работают как обычные выходы, ВХоды утянуты к плюсу питания

  @param    9) WirelessWakeUpTime:        Время "пробуждения" высокочастотной части RF-модуля. Зависит от режима работы.
                  WAKE_UP_TIME_250MS
                  WAKE_UP_TIME_500MS
                  WAKE_UP_TIME_750MS
                  WAKE_UP_TIME_1000MS
                  WAKE_UP_TIME_1250MS
                  WAKE_UP_TIME_1500MS
                  WAKE_UP_TIME_1750MS
                  WAKE_UP_TIME_2000MS

  @param    10) FEC_Enable_Switch:        Включение функции исправления ошибок при беспроводной передаче.
                  FEC_DISABLE
                  FEC_ENABLE

  @param    11) Transmission_Power_dBm:        Установка выходной мощности передатчика.
                  RF_POWER_20dBm - 100 mW
                  RF_POWER_17dBm - 50 mW
                  RF_POWER_14dBm - 25 mW
                  RF_POWER_10dBm - 10 mW


  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка



  struct FixedStransmissionString {
		byte ADDH = 0;
		byte ADDL = 0;
		byte CHAN = 0;
		char message[];
	} fixedStransmission;

	fixedStransmission.ADDH = ADDH;
	fixedStransmission.ADDL = ADDL;
	fixedStransmission.CHAN = CHAN;

  sendFixedMessage(byte ADDH, byte ADDL, byte CHAN, const String message)


  @example

  SetParametersOfRFmodule( DO_NOT_SAVE_THE_PARAMETERS_WHEN_POWER_DOWN,
                            UART_BAUD_RATE_9600bps,
                              UART_8N1,
                                0,
                                  AIR_BAUD_RATE_2400bps,
                                    CHANNEL_6_FREQUENCY_868_MHZ,
                                      TRANSPARENT_TRANSMISSION_MODE,
                                        PUSH_PULL_OUTPUTS_AND_PULL_UP_INPUTS,
                                          WAKE_UP_TIME_250MS,
                                            FEC_DISABLE,
                                              RF_POWER_10dBm );

————————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef SetParametersOfRFmodule( Saving_Parameters_When_Power_Down SavingParameter,
                                            UART_Baud_Rate UART_BaudRate,
                                              UART_Parity_Bit UART_BitsFormat,
                                                u16 u16_WirelessDeviceAddress,
                                                  Air_Baud_Rate AirBaudRate,
                                                    Wireless_Channel Channel,
                                                      Transmission_Mode TransmitMode,
                                                        Type_Of_Inputs_Outputs TypeOfPins,
                                                          WirelessWakeUpTime WakeUpTime,
                                                            FEC_Enable_Switch FEC_Switch,
                                                              Transmission_Power_dBm TransmitPower )
{
  u32 u32_TickCounter;  // переменная отсчёта времени (мс) ожидания
  HAL_StatusTypeDef ReturnStatus;

  // Проверка на наличие питания RF-модуля
  if (!(g_u8_PowerLines & RF_MODULE_POWER_FLAG)) // Если питание RF-модуля ВЫКЛючено, то...
  { // ... ВКЛючаем питание RF-модуля
    PowerSwitch (RF_MODULE_POWER, POWER_ON);
  }
  
  // Установить режим программирования/чтения внутренних установок модуля EBYTE
  if ( (0 == (E32_M0_GPIO_Port->ODR & E32_M0_Pin)) || (0 == (E32_M1_GPIO_Port->ODR & E32_M1_Pin)) ) // Если "ноль" на M0 или M1, то...  
  { // ...устанавливаем их в "1"
    if (SWITCHED_MODE_NORMALLY != SetOperatingModeRFmodule_E32_900T20S (MODE_PROGRAM))
    {
      return HAL_ERROR;
    }
  }

  // Настраиваем значение счётчика максимального времени ожидания появления "единицы" на AUX
  u32_TickCounter = HAL_GetTick() + AUX_TIMEOUT_AFTER_POWER_ON;

  // Ожидание "единицы" на выходе "AUX" RF-модуля
  while ( HAL_GetTick() < u32_TickCounter )
  {
    if (HIGH == HAL_GPIO_ReadPin(E32_AUX_GPIO_Port, E32_AUX_Pin))
    {
      HAL_Delay(5); // рекомендуемая производителем задержа

      // Заполняем массив передачи данных RF-модулю полученными процедурой значениями
      g_u_ParametersOfRFmodule.Parameter.u8_Command = SavingParameter;    // 0xC0 или 0XC2
      g_u_ParametersOfRFmodule.Parameter.u8_AddressHigh = (u8)(u16_WirelessDeviceAddress & 0xFF00) >> 8;
      g_u_ParametersOfRFmodule.Parameter.u8_AddressLow = (u8)(u16_WirelessDeviceAddress & 0x00FF);
      g_u_ParametersOfRFmodule.Parameter.u8_Speed = 0 | UART_BitsFormat | UART_BaudRate | AirBaudRate;
      g_u_ParametersOfRFmodule.Parameter.u8_Channel = Channel;
      g_u_ParametersOfRFmodule.Parameter.u8_Options = 0 | TransmitMode | TypeOfPins | WakeUpTime | FEC_Switch | TransmitPower;

      // Отправляем содержимое массива параметров по UART2
      if (HAL_OK != (ReturnStatus = HAL_UART_Transmit(&huart2,
                                                        g_u_ParametersOfRFmodule.u8_a_ParametersArray,
                                                          sizeof (g_u_ParametersOfRFmodule.u8_a_ParametersArray),
                                                            TIME_OUT_OF_TRANSMITTER_UART2)))
      {
        return ReturnStatus;
      }
      
      HAL_Delay(5); // рекомендуемая производителем задержа
      return HAL_OK;
    }
  }
  return HAL_TIMEOUT;
}



//* Приём параметров портом UART2 от RF-модуля
/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    ReceivingParametersFromRFmodule - Приём параметров портом UART2 от RF-модуля через порт UART2

            Параметры сохраняются в глобальный массив g_u_ParametersOfRFmodule.u8_a_ParametersArray[]

  @retval   HAL_OK: 	  всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка

  @example

  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef ReceivingParametersFromRFmodule ()
{
  u8 u8_ByteCounter=0;    // переменная подсчёта принятых байт
  u32 u32_TickCounter;  // переменная отсчёта времени (мс) ожидания
  huart2.Instance = USART2;
  HAL_StatusTypeDef ReturnStatus;

  // Цикл чтения пакета данных от подчинённого устройства
  while (1)
  {
    // Настраиваем значение счётчика окончания ожидания приёма байта от датчика
    u32_TickCounter = HAL_GetTick() + TIME_OUT_OF_RECEIVER_BYTE_UART2;

    // Крутимся в цикле пока не получим один байт в буфер приёма
    while ( HAL_GetTick() < u32_TickCounter )
    {
      // Как дождались получение байта (появление флага занятости буфера), ....
      if (__HAL_UART_GET_FLAG (&huart2, UART_FLAG_RXNE))
      {
        // ... так сразу читаем этот байт в массив принятых данных
        if (HAL_OK != (ReturnStatus = HAL_UART_Receive(&huart2, 
                                                        &g_u_ParametersOfRFmodule.u8_a_ParametersArray [u8_ByteCounter++], 
                                                          1, 
                                                            TIME_OUT_OF_RECEIVER_BYTE_UART2)))
        {
          return ReturnStatus;
        }
        break;
      }
    }

    //Если вышли из цикла по ожиданию приёма байта (байты в буфер не поступают/перестали поступать)...
    if (HAL_GetTick() >= u32_TickCounter)
    {
      if (0 == u8_ByteCounter)
      {
        return HAL_TIMEOUT;
      }

      // Если же что-то принято, вываливаемся из цикла приёма (break;) и начинаем анализ принятых данных
      break;
    }
  } // ------------------  end of FOR-loop by u8_ByteCounter -----------------------------------

  // Проверка соответствия первого байта (должен быть 0xC0)
  if (0xC0 != g_u_ParametersOfRFmodule.u8_a_ParametersArray[0])
  {
    return HAL_ERROR;
  }

  #ifdef UART2_PARAM_OLED // #####################################################################################################################

    // Так как первый байт 0xC0, то это означает, что далее идут параметры RF-модуля

    OLED1_Font_8x6_printf(1, 10, "Param. E32-900T20S");
    OLED1_Font_8x6_printf(3, 1, "ADDR:%u F:%uMHz CH:%u", (((u16) g_u_ParametersOfRFmodule.u8_a_ParametersArray[1]) << 8) | (u16)(g_u_ParametersOfRFmodule.u8_a_ParametersArray[2]),
                                                              g_u_ParametersOfRFmodule.u8_a_ParametersArray[4]+862, g_u_ParametersOfRFmodule.u8_a_ParametersArray[4]);

    OLED1_Font_8x6_printf(4, 1, PRINTF_BINARY_PATTERN_INT8 " - Rate", PRINTF_BYTE_TO_BINARY_INT8 (g_u_ParametersOfRFmodule.u8_a_ParametersArray[3]));
    OLED1_Font_8x6_printf(5, 1, PRINTF_BINARY_PATTERN_INT8 " - Options", PRINTF_BYTE_TO_BINARY_INT8 (g_u_ParametersOfRFmodule.u8_a_ParametersArray[5]));

  #endif  // #####################################################################################################################################


  return HAL_OK;

}




//* Запрос параметров RF-модуля портом UART2
/** ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
  @brief    RequestParametersFromRFmodule - Запрос параметров через порт UART2 от RF-модуля

  @retval   HAL_OK: 	  всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка

  @example

  —————————————————————————————————————————————————————————————————————————————————————————————————————————————— */
HAL_StatusTypeDef RequestParametersFromRFmodule()
{
  u8 u8_a_Command [3] = CODE_SEQUENCE_FOR_REQUESTING_PARAMETERS; // Код запроса параметров (Globals.h)
  u32 u32_TickCounter;  // переменная отсчёта времени (мс) ожидания
  huart2.Instance = USART2;
  HAL_StatusTypeDef ReturnStatus;


  // Настраиваем значение счётчика максимального времени ожидания появления "единицы" на AUX
  u32_TickCounter = HAL_GetTick() + AUX_TIMEOUT_AFTER_POWER_ON;

  // Ожидание "единицы" на выходе "AUX" RF-модуля
  while ( HAL_GetTick() < u32_TickCounter )
  {
    if (HIGH == HAL_GPIO_ReadPin(E32_AUX_GPIO_Port, E32_AUX_Pin))
    {
      HAL_Delay(5); // рекомендуемая производителем задержа

      // Отправляем содержимое массива параметров по UART2
      if (HAL_OK != (ReturnStatus = HAL_UART_Transmit(&huart2, u8_a_Command, 3, TIME_OUT_OF_TRANSMITTER_UART2)))
      {
        return ReturnStatus;
      }
    }
  }
  return HAL_TIMEOUT;
}




/** ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  @brief    DataTransmitToRF-module - запись данных в модуль RF

  @param    1)*u8_p_TransmitData:       ссылка на байтовый массив данных, которые нужно записать во FRAM
  @param    2)u8_SizeOfTransmitData:    размер массива пересылаемых данных
  @param    3)u16_StartAddressInFRAM:   адрес, с которого будет происходить запись (адресное простр-во FRAM 0...1FFFh (0...8191))


  Freq Now: 868,0MHz
  Param Now: 0x0, 0xe, 0x1a, 0x6, 0xc4

  Address: 0xE, Channel: 0x6
  UART Rate: 9600, Parity: 8N1, Air Rate: 2400, Power: 20 dBm, FEC: Enable, Fixed mode: Enable, WOR Timing: 250 mS, IO Mode: PushPull
  __________________________________________________________________________________________________________________________________________

  @retval   HAL_OK: 	    всё в норме
  @retval 	HAL_ERROR: 	  ошибка
  @retval 	HAL_BUSY:  	  ошибка
  @retval 	HAL_TIMEOUT:  ошибка

  @example

  ___________________________________________________________________________________________________________________________________________ */
// HAL_StatusTypeDef DataTransmitToRF_module (u8 *u8_p_TransmitData, u8 u8_SizeOfTransmitData, u16 u16_StartAddressInFRAM)
// {

//   return HAL_OK;

// }







/*********************************** END OF FILE ************************************/
